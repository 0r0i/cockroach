// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: cockroach/proto/structured.proto

#define INTERNAL_SUPPRESS_PROTOBUF_FIELD_DEPRECATION
#include "cockroach/proto/structured.pb.h"

#include <algorithm>

#include <google/protobuf/stubs/common.h>
#include <google/protobuf/stubs/once.h>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/wire_format_lite_inl.h>
#include <google/protobuf/descriptor.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/reflection_ops.h>
#include <google/protobuf/wire_format.h>
// @@protoc_insertion_point(includes)

namespace cockroach {
namespace proto {

namespace {

const ::google::protobuf::Descriptor* Table_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Table_reflection_ = NULL;
const ::google::protobuf::Descriptor* Column_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Column_reflection_ = NULL;
const ::google::protobuf::EnumDescriptor* Column_ColumnType_descriptor_ = NULL;
const ::google::protobuf::Descriptor* Index_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Index_reflection_ = NULL;
const ::google::protobuf::Descriptor* TableSchema_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  TableSchema_reflection_ = NULL;
const ::google::protobuf::Descriptor* TableSchema_IndexByName_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  TableSchema_IndexByName_reflection_ = NULL;
const ::google::protobuf::Descriptor* ColumnDescriptor_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  ColumnDescriptor_reflection_ = NULL;
const ::google::protobuf::Descriptor* IndexDescriptor_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  IndexDescriptor_reflection_ = NULL;
const ::google::protobuf::Descriptor* TableDescriptor_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  TableDescriptor_reflection_ = NULL;
const ::google::protobuf::Descriptor* CreateTableRequest_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  CreateTableRequest_reflection_ = NULL;
const ::google::protobuf::Descriptor* CreateTableResponse_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  CreateTableResponse_reflection_ = NULL;

}  // namespace


void protobuf_AssignDesc_cockroach_2fproto_2fstructured_2eproto() {
  protobuf_AddDesc_cockroach_2fproto_2fstructured_2eproto();
  const ::google::protobuf::FileDescriptor* file =
    ::google::protobuf::DescriptorPool::generated_pool()->FindFileByName(
      "cockroach/proto/structured.proto");
  GOOGLE_CHECK(file != NULL);
  Table_descriptor_ = file->message_type(0);
  static const int Table_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Table, name_),
  };
  Table_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      Table_descriptor_,
      Table::default_instance_,
      Table_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Table, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Table, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(Table));
  Column_descriptor_ = file->message_type(1);
  static const int Column_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Column, name_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Column, type_),
  };
  Column_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      Column_descriptor_,
      Column::default_instance_,
      Column_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Column, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Column, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(Column));
  Column_ColumnType_descriptor_ = Column_descriptor_->enum_type(0);
  Index_descriptor_ = file->message_type(2);
  static const int Index_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Index, name_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Index, unique_),
  };
  Index_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      Index_descriptor_,
      Index::default_instance_,
      Index_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Index, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Index, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(Index));
  TableSchema_descriptor_ = file->message_type(3);
  static const int TableSchema_offsets_[3] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TableSchema, table_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TableSchema, columns_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TableSchema, indexes_),
  };
  TableSchema_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      TableSchema_descriptor_,
      TableSchema::default_instance_,
      TableSchema_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TableSchema, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TableSchema, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(TableSchema));
  TableSchema_IndexByName_descriptor_ = TableSchema_descriptor_->nested_type(0);
  static const int TableSchema_IndexByName_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TableSchema_IndexByName, index_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TableSchema_IndexByName, column_names_),
  };
  TableSchema_IndexByName_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      TableSchema_IndexByName_descriptor_,
      TableSchema_IndexByName::default_instance_,
      TableSchema_IndexByName_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TableSchema_IndexByName, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TableSchema_IndexByName, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(TableSchema_IndexByName));
  ColumnDescriptor_descriptor_ = file->message_type(4);
  static const int ColumnDescriptor_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ColumnDescriptor, id_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ColumnDescriptor, column_),
  };
  ColumnDescriptor_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      ColumnDescriptor_descriptor_,
      ColumnDescriptor::default_instance_,
      ColumnDescriptor_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ColumnDescriptor, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ColumnDescriptor, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(ColumnDescriptor));
  IndexDescriptor_descriptor_ = file->message_type(5);
  static const int IndexDescriptor_offsets_[3] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(IndexDescriptor, id_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(IndexDescriptor, index_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(IndexDescriptor, column_ids_),
  };
  IndexDescriptor_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      IndexDescriptor_descriptor_,
      IndexDescriptor::default_instance_,
      IndexDescriptor_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(IndexDescriptor, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(IndexDescriptor, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(IndexDescriptor));
  TableDescriptor_descriptor_ = file->message_type(6);
  static const int TableDescriptor_offsets_[6] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TableDescriptor, id_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TableDescriptor, table_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TableDescriptor, columns_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TableDescriptor, next_column_id_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TableDescriptor, indexes_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TableDescriptor, next_index_id_),
  };
  TableDescriptor_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      TableDescriptor_descriptor_,
      TableDescriptor::default_instance_,
      TableDescriptor_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TableDescriptor, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TableDescriptor, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(TableDescriptor));
  CreateTableRequest_descriptor_ = file->message_type(7);
  static const int CreateTableRequest_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CreateTableRequest, header_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CreateTableRequest, schema_),
  };
  CreateTableRequest_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      CreateTableRequest_descriptor_,
      CreateTableRequest::default_instance_,
      CreateTableRequest_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CreateTableRequest, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CreateTableRequest, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(CreateTableRequest));
  CreateTableResponse_descriptor_ = file->message_type(8);
  static const int CreateTableResponse_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CreateTableResponse, error_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CreateTableResponse, table_id_),
  };
  CreateTableResponse_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      CreateTableResponse_descriptor_,
      CreateTableResponse::default_instance_,
      CreateTableResponse_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CreateTableResponse, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CreateTableResponse, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(CreateTableResponse));
}

namespace {

GOOGLE_PROTOBUF_DECLARE_ONCE(protobuf_AssignDescriptors_once_);
inline void protobuf_AssignDescriptorsOnce() {
  ::google::protobuf::GoogleOnceInit(&protobuf_AssignDescriptors_once_,
                 &protobuf_AssignDesc_cockroach_2fproto_2fstructured_2eproto);
}

void protobuf_RegisterTypes(const ::std::string&) {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    Table_descriptor_, &Table::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    Column_descriptor_, &Column::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    Index_descriptor_, &Index::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    TableSchema_descriptor_, &TableSchema::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    TableSchema_IndexByName_descriptor_, &TableSchema_IndexByName::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    ColumnDescriptor_descriptor_, &ColumnDescriptor::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    IndexDescriptor_descriptor_, &IndexDescriptor::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    TableDescriptor_descriptor_, &TableDescriptor::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    CreateTableRequest_descriptor_, &CreateTableRequest::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    CreateTableResponse_descriptor_, &CreateTableResponse::default_instance());
}

}  // namespace

void protobuf_ShutdownFile_cockroach_2fproto_2fstructured_2eproto() {
  delete Table::default_instance_;
  delete Table_reflection_;
  delete Column::default_instance_;
  delete Column_reflection_;
  delete Index::default_instance_;
  delete Index_reflection_;
  delete TableSchema::default_instance_;
  delete TableSchema_reflection_;
  delete TableSchema_IndexByName::default_instance_;
  delete TableSchema_IndexByName_reflection_;
  delete ColumnDescriptor::default_instance_;
  delete ColumnDescriptor_reflection_;
  delete IndexDescriptor::default_instance_;
  delete IndexDescriptor_reflection_;
  delete TableDescriptor::default_instance_;
  delete TableDescriptor_reflection_;
  delete CreateTableRequest::default_instance_;
  delete CreateTableRequest_reflection_;
  delete CreateTableResponse::default_instance_;
  delete CreateTableResponse_reflection_;
}

void protobuf_AddDesc_cockroach_2fproto_2fstructured_2eproto() {
  static bool already_here = false;
  if (already_here) return;
  already_here = true;
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  ::gogoproto::protobuf_AddDesc_gogoproto_2fgogo_2eproto();
  ::cockroach::proto::protobuf_AddDesc_cockroach_2fproto_2fapi_2eproto();
  ::cockroach::proto::protobuf_AddDesc_cockroach_2fproto_2ferrors_2eproto();
  ::google::protobuf::DescriptorPool::InternalAddGeneratedFile(
    "\n cockroach/proto/structured.proto\022\017cock"
    "roach.proto\032\024gogoproto/gogo.proto\032\031cockr"
    "oach/proto/api.proto\032\034cockroach/proto/er"
    "rors.proto\"\033\n\005Table\022\022\n\004name\030\001 \001(\tB\004\310\336\037\000\""
    "m\n\006Column\022\022\n\004name\030\001 \001(\tB\004\310\336\037\000\0226\n\004type\030\002 "
    "\001(\0162\".cockroach.proto.Column.ColumnTypeB"
    "\004\310\336\037\000\"\027\n\nColumnType\022\t\n\005BYTES\020\000\"1\n\005Index\022"
    "\022\n\004name\030\001 \001(\tB\004\310\336\037\000\022\024\n\006unique\030\002 \001(\010B\004\310\336\037"
    "\000\"\213\002\n\013TableSchema\022/\n\005table\030\001 \001(\0132\026.cockr"
    "oach.proto.TableB\010\310\336\037\000\320\336\037\001\022.\n\007columns\030\002 "
    "\003(\0132\027.cockroach.proto.ColumnB\004\310\336\037\000\022\?\n\007in"
    "dexes\030\003 \003(\0132(.cockroach.proto.TableSchem"
    "a.IndexByNameB\004\310\336\037\000\032Z\n\013IndexByName\022/\n\005in"
    "dex\030\001 \001(\0132\026.cockroach.proto.IndexB\010\310\336\037\000\320"
    "\336\037\001\022\032\n\014column_names\030\002 \003(\tB\004\310\336\037\000\"W\n\020Colum"
    "nDescriptor\022\020\n\002id\030\001 \001(\rB\004\310\336\037\000\0221\n\006column\030"
    "\002 \001(\0132\027.cockroach.proto.ColumnB\010\310\336\037\000\320\336\037\001"
    "\"n\n\017IndexDescriptor\022\020\n\002id\030\001 \001(\rB\004\310\336\037\000\022/\n"
    "\005index\030\002 \001(\0132\026.cockroach.proto.IndexB\010\310\336"
    "\037\000\320\336\037\001\022\030\n\ncolumn_ids\030\003 \003(\rB\004\310\336\037\000\"\202\002\n\017Tab"
    "leDescriptor\022\020\n\002id\030\001 \001(\rB\004\310\336\037\000\022/\n\005table\030"
    "\002 \001(\0132\026.cockroach.proto.TableB\010\310\336\037\000\320\336\037\001\022"
    "8\n\007columns\030\003 \003(\0132!.cockroach.proto.Colum"
    "nDescriptorB\004\310\336\037\000\022\034\n\016next_column_id\030\004 \001("
    "\rB\004\310\336\037\000\0227\n\007indexes\030\005 \003(\0132 .cockroach.pro"
    "to.IndexDescriptorB\004\310\336\037\000\022\033\n\rnext_index_i"
    "d\030\006 \001(\rB\004\310\336\037\000\"\202\001\n\022CreateTableRequest\0228\n\006"
    "header\030\001 \001(\0132\036.cockroach.proto.RequestHe"
    "aderB\010\310\336\037\000\320\336\037\001\0222\n\006schema\030\002 \001(\0132\034.cockroa"
    "ch.proto.TableSchemaB\004\310\336\037\000\"Z\n\023CreateTabl"
    "eResponse\022+\n\005error\030\001 \001(\0132\026.cockroach.pro"
    "to.ErrorB\004\310\336\037\000\022\026\n\010table_id\030\002 \001(\rB\004\310\336\037\0002i"
    "\n\rSchemaService\022X\n\013CreateTable\022#.cockroa"
    "ch.proto.CreateTableRequest\032$.cockroach."
    "proto.CreateTableResponseB\023Z\005proto\340\342\036\001\310\342"
    "\036\001\320\342\036\001", 1406);
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedFile(
    "cockroach/proto/structured.proto", &protobuf_RegisterTypes);
  Table::default_instance_ = new Table();
  Column::default_instance_ = new Column();
  Index::default_instance_ = new Index();
  TableSchema::default_instance_ = new TableSchema();
  TableSchema_IndexByName::default_instance_ = new TableSchema_IndexByName();
  ColumnDescriptor::default_instance_ = new ColumnDescriptor();
  IndexDescriptor::default_instance_ = new IndexDescriptor();
  TableDescriptor::default_instance_ = new TableDescriptor();
  CreateTableRequest::default_instance_ = new CreateTableRequest();
  CreateTableResponse::default_instance_ = new CreateTableResponse();
  Table::default_instance_->InitAsDefaultInstance();
  Column::default_instance_->InitAsDefaultInstance();
  Index::default_instance_->InitAsDefaultInstance();
  TableSchema::default_instance_->InitAsDefaultInstance();
  TableSchema_IndexByName::default_instance_->InitAsDefaultInstance();
  ColumnDescriptor::default_instance_->InitAsDefaultInstance();
  IndexDescriptor::default_instance_->InitAsDefaultInstance();
  TableDescriptor::default_instance_->InitAsDefaultInstance();
  CreateTableRequest::default_instance_->InitAsDefaultInstance();
  CreateTableResponse::default_instance_->InitAsDefaultInstance();
  ::google::protobuf::internal::OnShutdown(&protobuf_ShutdownFile_cockroach_2fproto_2fstructured_2eproto);
}

// Force AddDescriptors() to be called at static initialization time.
struct StaticDescriptorInitializer_cockroach_2fproto_2fstructured_2eproto {
  StaticDescriptorInitializer_cockroach_2fproto_2fstructured_2eproto() {
    protobuf_AddDesc_cockroach_2fproto_2fstructured_2eproto();
  }
} static_descriptor_initializer_cockroach_2fproto_2fstructured_2eproto_;

// ===================================================================

#ifndef _MSC_VER
const int Table::kNameFieldNumber;
#endif  // !_MSC_VER

Table::Table()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:cockroach.proto.Table)
}

void Table::InitAsDefaultInstance() {
}

Table::Table(const Table& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:cockroach.proto.Table)
}

void Table::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Table::~Table() {
  // @@protoc_insertion_point(destructor:cockroach.proto.Table)
  SharedDtor();
}

void Table::SharedDtor() {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete name_;
  }
  if (this != default_instance_) {
  }
}

void Table::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Table::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Table_descriptor_;
}

const Table& Table::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_cockroach_2fproto_2fstructured_2eproto();
  return *default_instance_;
}

Table* Table::default_instance_ = NULL;

Table* Table::New() const {
  return new Table;
}

void Table::Clear() {
  if (has_name()) {
    if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
      name_->clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool Table::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:cockroach.proto.Table)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional string name = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_name()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->name().data(), this->name().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "name");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:cockroach.proto.Table)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:cockroach.proto.Table)
  return false;
#undef DO_
}

void Table::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:cockroach.proto.Table)
  // optional string name = 1;
  if (has_name()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->name().data(), this->name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "name");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      1, this->name(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:cockroach.proto.Table)
}

::google::protobuf::uint8* Table::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:cockroach.proto.Table)
  // optional string name = 1;
  if (has_name()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->name().data(), this->name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "name");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        1, this->name(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:cockroach.proto.Table)
  return target;
}

int Table::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional string name = 1;
    if (has_name()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->name());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Table::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const Table* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const Table*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void Table::MergeFrom(const Table& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_name()) {
      set_name(from.name());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void Table::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Table::CopyFrom(const Table& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Table::IsInitialized() const {

  return true;
}

void Table::Swap(Table* other) {
  if (other != this) {
    std::swap(name_, other->name_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata Table::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Table_descriptor_;
  metadata.reflection = Table_reflection_;
  return metadata;
}


// ===================================================================

const ::google::protobuf::EnumDescriptor* Column_ColumnType_descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Column_ColumnType_descriptor_;
}
bool Column_ColumnType_IsValid(int value) {
  switch(value) {
    case 0:
      return true;
    default:
      return false;
  }
}

#ifndef _MSC_VER
const Column_ColumnType Column::BYTES;
const Column_ColumnType Column::ColumnType_MIN;
const Column_ColumnType Column::ColumnType_MAX;
const int Column::ColumnType_ARRAYSIZE;
#endif  // _MSC_VER
#ifndef _MSC_VER
const int Column::kNameFieldNumber;
const int Column::kTypeFieldNumber;
#endif  // !_MSC_VER

Column::Column()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:cockroach.proto.Column)
}

void Column::InitAsDefaultInstance() {
}

Column::Column(const Column& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:cockroach.proto.Column)
}

void Column::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  type_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Column::~Column() {
  // @@protoc_insertion_point(destructor:cockroach.proto.Column)
  SharedDtor();
}

void Column::SharedDtor() {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete name_;
  }
  if (this != default_instance_) {
  }
}

void Column::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Column::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Column_descriptor_;
}

const Column& Column::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_cockroach_2fproto_2fstructured_2eproto();
  return *default_instance_;
}

Column* Column::default_instance_ = NULL;

Column* Column::New() const {
  return new Column;
}

void Column::Clear() {
  if (_has_bits_[0 / 32] & 3) {
    if (has_name()) {
      if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        name_->clear();
      }
    }
    type_ = 0;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool Column::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:cockroach.proto.Column)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional string name = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_name()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->name().data(), this->name().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "name");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_type;
        break;
      }

      // optional .cockroach.proto.Column.ColumnType type = 2;
      case 2: {
        if (tag == 16) {
         parse_type:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::cockroach::proto::Column_ColumnType_IsValid(value)) {
            set_type(static_cast< ::cockroach::proto::Column_ColumnType >(value));
          } else {
            mutable_unknown_fields()->AddVarint(2, value);
          }
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:cockroach.proto.Column)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:cockroach.proto.Column)
  return false;
#undef DO_
}

void Column::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:cockroach.proto.Column)
  // optional string name = 1;
  if (has_name()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->name().data(), this->name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "name");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      1, this->name(), output);
  }

  // optional .cockroach.proto.Column.ColumnType type = 2;
  if (has_type()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      2, this->type(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:cockroach.proto.Column)
}

::google::protobuf::uint8* Column::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:cockroach.proto.Column)
  // optional string name = 1;
  if (has_name()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->name().data(), this->name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "name");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        1, this->name(), target);
  }

  // optional .cockroach.proto.Column.ColumnType type = 2;
  if (has_type()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      2, this->type(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:cockroach.proto.Column)
  return target;
}

int Column::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional string name = 1;
    if (has_name()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->name());
    }

    // optional .cockroach.proto.Column.ColumnType type = 2;
    if (has_type()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->type());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Column::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const Column* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const Column*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void Column::MergeFrom(const Column& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_name()) {
      set_name(from.name());
    }
    if (from.has_type()) {
      set_type(from.type());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void Column::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Column::CopyFrom(const Column& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Column::IsInitialized() const {

  return true;
}

void Column::Swap(Column* other) {
  if (other != this) {
    std::swap(name_, other->name_);
    std::swap(type_, other->type_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata Column::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Column_descriptor_;
  metadata.reflection = Column_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int Index::kNameFieldNumber;
const int Index::kUniqueFieldNumber;
#endif  // !_MSC_VER

Index::Index()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:cockroach.proto.Index)
}

void Index::InitAsDefaultInstance() {
}

Index::Index(const Index& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:cockroach.proto.Index)
}

void Index::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  unique_ = false;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Index::~Index() {
  // @@protoc_insertion_point(destructor:cockroach.proto.Index)
  SharedDtor();
}

void Index::SharedDtor() {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete name_;
  }
  if (this != default_instance_) {
  }
}

void Index::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Index::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Index_descriptor_;
}

const Index& Index::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_cockroach_2fproto_2fstructured_2eproto();
  return *default_instance_;
}

Index* Index::default_instance_ = NULL;

Index* Index::New() const {
  return new Index;
}

void Index::Clear() {
  if (_has_bits_[0 / 32] & 3) {
    if (has_name()) {
      if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        name_->clear();
      }
    }
    unique_ = false;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool Index::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:cockroach.proto.Index)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional string name = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_name()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->name().data(), this->name().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "name");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_unique;
        break;
      }

      // optional bool unique = 2;
      case 2: {
        if (tag == 16) {
         parse_unique:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &unique_)));
          set_has_unique();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:cockroach.proto.Index)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:cockroach.proto.Index)
  return false;
#undef DO_
}

void Index::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:cockroach.proto.Index)
  // optional string name = 1;
  if (has_name()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->name().data(), this->name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "name");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      1, this->name(), output);
  }

  // optional bool unique = 2;
  if (has_unique()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(2, this->unique(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:cockroach.proto.Index)
}

::google::protobuf::uint8* Index::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:cockroach.proto.Index)
  // optional string name = 1;
  if (has_name()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->name().data(), this->name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "name");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        1, this->name(), target);
  }

  // optional bool unique = 2;
  if (has_unique()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(2, this->unique(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:cockroach.proto.Index)
  return target;
}

int Index::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional string name = 1;
    if (has_name()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->name());
    }

    // optional bool unique = 2;
    if (has_unique()) {
      total_size += 1 + 1;
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Index::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const Index* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const Index*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void Index::MergeFrom(const Index& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_name()) {
      set_name(from.name());
    }
    if (from.has_unique()) {
      set_unique(from.unique());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void Index::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Index::CopyFrom(const Index& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Index::IsInitialized() const {

  return true;
}

void Index::Swap(Index* other) {
  if (other != this) {
    std::swap(name_, other->name_);
    std::swap(unique_, other->unique_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata Index::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Index_descriptor_;
  metadata.reflection = Index_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int TableSchema_IndexByName::kIndexFieldNumber;
const int TableSchema_IndexByName::kColumnNamesFieldNumber;
#endif  // !_MSC_VER

TableSchema_IndexByName::TableSchema_IndexByName()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:cockroach.proto.TableSchema.IndexByName)
}

void TableSchema_IndexByName::InitAsDefaultInstance() {
  index_ = const_cast< ::cockroach::proto::Index*>(&::cockroach::proto::Index::default_instance());
}

TableSchema_IndexByName::TableSchema_IndexByName(const TableSchema_IndexByName& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:cockroach.proto.TableSchema.IndexByName)
}

void TableSchema_IndexByName::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  index_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

TableSchema_IndexByName::~TableSchema_IndexByName() {
  // @@protoc_insertion_point(destructor:cockroach.proto.TableSchema.IndexByName)
  SharedDtor();
}

void TableSchema_IndexByName::SharedDtor() {
  if (this != default_instance_) {
    delete index_;
  }
}

void TableSchema_IndexByName::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* TableSchema_IndexByName::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return TableSchema_IndexByName_descriptor_;
}

const TableSchema_IndexByName& TableSchema_IndexByName::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_cockroach_2fproto_2fstructured_2eproto();
  return *default_instance_;
}

TableSchema_IndexByName* TableSchema_IndexByName::default_instance_ = NULL;

TableSchema_IndexByName* TableSchema_IndexByName::New() const {
  return new TableSchema_IndexByName;
}

void TableSchema_IndexByName::Clear() {
  if (has_index()) {
    if (index_ != NULL) index_->::cockroach::proto::Index::Clear();
  }
  column_names_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool TableSchema_IndexByName::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:cockroach.proto.TableSchema.IndexByName)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .cockroach.proto.Index index = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_index()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_column_names;
        break;
      }

      // repeated string column_names = 2;
      case 2: {
        if (tag == 18) {
         parse_column_names:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->add_column_names()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->column_names(this->column_names_size() - 1).data(),
            this->column_names(this->column_names_size() - 1).length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "column_names");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_column_names;
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:cockroach.proto.TableSchema.IndexByName)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:cockroach.proto.TableSchema.IndexByName)
  return false;
#undef DO_
}

void TableSchema_IndexByName::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:cockroach.proto.TableSchema.IndexByName)
  // optional .cockroach.proto.Index index = 1;
  if (has_index()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->index(), output);
  }

  // repeated string column_names = 2;
  for (int i = 0; i < this->column_names_size(); i++) {
  ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
    this->column_names(i).data(), this->column_names(i).length(),
    ::google::protobuf::internal::WireFormat::SERIALIZE,
    "column_names");
    ::google::protobuf::internal::WireFormatLite::WriteString(
      2, this->column_names(i), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:cockroach.proto.TableSchema.IndexByName)
}

::google::protobuf::uint8* TableSchema_IndexByName::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:cockroach.proto.TableSchema.IndexByName)
  // optional .cockroach.proto.Index index = 1;
  if (has_index()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->index(), target);
  }

  // repeated string column_names = 2;
  for (int i = 0; i < this->column_names_size(); i++) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->column_names(i).data(), this->column_names(i).length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "column_names");
    target = ::google::protobuf::internal::WireFormatLite::
      WriteStringToArray(2, this->column_names(i), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:cockroach.proto.TableSchema.IndexByName)
  return target;
}

int TableSchema_IndexByName::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional .cockroach.proto.Index index = 1;
    if (has_index()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->index());
    }

  }
  // repeated string column_names = 2;
  total_size += 1 * this->column_names_size();
  for (int i = 0; i < this->column_names_size(); i++) {
    total_size += ::google::protobuf::internal::WireFormatLite::StringSize(
      this->column_names(i));
  }

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void TableSchema_IndexByName::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const TableSchema_IndexByName* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const TableSchema_IndexByName*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void TableSchema_IndexByName::MergeFrom(const TableSchema_IndexByName& from) {
  GOOGLE_CHECK_NE(&from, this);
  column_names_.MergeFrom(from.column_names_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_index()) {
      mutable_index()->::cockroach::proto::Index::MergeFrom(from.index());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void TableSchema_IndexByName::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void TableSchema_IndexByName::CopyFrom(const TableSchema_IndexByName& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TableSchema_IndexByName::IsInitialized() const {

  return true;
}

void TableSchema_IndexByName::Swap(TableSchema_IndexByName* other) {
  if (other != this) {
    std::swap(index_, other->index_);
    column_names_.Swap(&other->column_names_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata TableSchema_IndexByName::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = TableSchema_IndexByName_descriptor_;
  metadata.reflection = TableSchema_IndexByName_reflection_;
  return metadata;
}


// -------------------------------------------------------------------

#ifndef _MSC_VER
const int TableSchema::kTableFieldNumber;
const int TableSchema::kColumnsFieldNumber;
const int TableSchema::kIndexesFieldNumber;
#endif  // !_MSC_VER

TableSchema::TableSchema()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:cockroach.proto.TableSchema)
}

void TableSchema::InitAsDefaultInstance() {
  table_ = const_cast< ::cockroach::proto::Table*>(&::cockroach::proto::Table::default_instance());
}

TableSchema::TableSchema(const TableSchema& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:cockroach.proto.TableSchema)
}

void TableSchema::SharedCtor() {
  _cached_size_ = 0;
  table_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

TableSchema::~TableSchema() {
  // @@protoc_insertion_point(destructor:cockroach.proto.TableSchema)
  SharedDtor();
}

void TableSchema::SharedDtor() {
  if (this != default_instance_) {
    delete table_;
  }
}

void TableSchema::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* TableSchema::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return TableSchema_descriptor_;
}

const TableSchema& TableSchema::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_cockroach_2fproto_2fstructured_2eproto();
  return *default_instance_;
}

TableSchema* TableSchema::default_instance_ = NULL;

TableSchema* TableSchema::New() const {
  return new TableSchema;
}

void TableSchema::Clear() {
  if (has_table()) {
    if (table_ != NULL) table_->::cockroach::proto::Table::Clear();
  }
  columns_.Clear();
  indexes_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool TableSchema::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:cockroach.proto.TableSchema)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .cockroach.proto.Table table = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_table()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_columns;
        break;
      }

      // repeated .cockroach.proto.Column columns = 2;
      case 2: {
        if (tag == 18) {
         parse_columns:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_columns()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_columns;
        if (input->ExpectTag(26)) goto parse_indexes;
        break;
      }

      // repeated .cockroach.proto.TableSchema.IndexByName indexes = 3;
      case 3: {
        if (tag == 26) {
         parse_indexes:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_indexes()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(26)) goto parse_indexes;
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:cockroach.proto.TableSchema)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:cockroach.proto.TableSchema)
  return false;
#undef DO_
}

void TableSchema::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:cockroach.proto.TableSchema)
  // optional .cockroach.proto.Table table = 1;
  if (has_table()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->table(), output);
  }

  // repeated .cockroach.proto.Column columns = 2;
  for (int i = 0; i < this->columns_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, this->columns(i), output);
  }

  // repeated .cockroach.proto.TableSchema.IndexByName indexes = 3;
  for (int i = 0; i < this->indexes_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      3, this->indexes(i), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:cockroach.proto.TableSchema)
}

::google::protobuf::uint8* TableSchema::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:cockroach.proto.TableSchema)
  // optional .cockroach.proto.Table table = 1;
  if (has_table()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->table(), target);
  }

  // repeated .cockroach.proto.Column columns = 2;
  for (int i = 0; i < this->columns_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, this->columns(i), target);
  }

  // repeated .cockroach.proto.TableSchema.IndexByName indexes = 3;
  for (int i = 0; i < this->indexes_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        3, this->indexes(i), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:cockroach.proto.TableSchema)
  return target;
}

int TableSchema::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional .cockroach.proto.Table table = 1;
    if (has_table()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->table());
    }

  }
  // repeated .cockroach.proto.Column columns = 2;
  total_size += 1 * this->columns_size();
  for (int i = 0; i < this->columns_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->columns(i));
  }

  // repeated .cockroach.proto.TableSchema.IndexByName indexes = 3;
  total_size += 1 * this->indexes_size();
  for (int i = 0; i < this->indexes_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->indexes(i));
  }

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void TableSchema::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const TableSchema* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const TableSchema*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void TableSchema::MergeFrom(const TableSchema& from) {
  GOOGLE_CHECK_NE(&from, this);
  columns_.MergeFrom(from.columns_);
  indexes_.MergeFrom(from.indexes_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_table()) {
      mutable_table()->::cockroach::proto::Table::MergeFrom(from.table());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void TableSchema::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void TableSchema::CopyFrom(const TableSchema& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TableSchema::IsInitialized() const {

  return true;
}

void TableSchema::Swap(TableSchema* other) {
  if (other != this) {
    std::swap(table_, other->table_);
    columns_.Swap(&other->columns_);
    indexes_.Swap(&other->indexes_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata TableSchema::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = TableSchema_descriptor_;
  metadata.reflection = TableSchema_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int ColumnDescriptor::kIdFieldNumber;
const int ColumnDescriptor::kColumnFieldNumber;
#endif  // !_MSC_VER

ColumnDescriptor::ColumnDescriptor()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:cockroach.proto.ColumnDescriptor)
}

void ColumnDescriptor::InitAsDefaultInstance() {
  column_ = const_cast< ::cockroach::proto::Column*>(&::cockroach::proto::Column::default_instance());
}

ColumnDescriptor::ColumnDescriptor(const ColumnDescriptor& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:cockroach.proto.ColumnDescriptor)
}

void ColumnDescriptor::SharedCtor() {
  _cached_size_ = 0;
  id_ = 0u;
  column_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ColumnDescriptor::~ColumnDescriptor() {
  // @@protoc_insertion_point(destructor:cockroach.proto.ColumnDescriptor)
  SharedDtor();
}

void ColumnDescriptor::SharedDtor() {
  if (this != default_instance_) {
    delete column_;
  }
}

void ColumnDescriptor::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* ColumnDescriptor::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return ColumnDescriptor_descriptor_;
}

const ColumnDescriptor& ColumnDescriptor::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_cockroach_2fproto_2fstructured_2eproto();
  return *default_instance_;
}

ColumnDescriptor* ColumnDescriptor::default_instance_ = NULL;

ColumnDescriptor* ColumnDescriptor::New() const {
  return new ColumnDescriptor;
}

void ColumnDescriptor::Clear() {
  if (_has_bits_[0 / 32] & 3) {
    id_ = 0u;
    if (has_column()) {
      if (column_ != NULL) column_->::cockroach::proto::Column::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool ColumnDescriptor::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:cockroach.proto.ColumnDescriptor)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional uint32 id = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &id_)));
          set_has_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_column;
        break;
      }

      // optional .cockroach.proto.Column column = 2;
      case 2: {
        if (tag == 18) {
         parse_column:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_column()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:cockroach.proto.ColumnDescriptor)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:cockroach.proto.ColumnDescriptor)
  return false;
#undef DO_
}

void ColumnDescriptor::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:cockroach.proto.ColumnDescriptor)
  // optional uint32 id = 1;
  if (has_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->id(), output);
  }

  // optional .cockroach.proto.Column column = 2;
  if (has_column()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, this->column(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:cockroach.proto.ColumnDescriptor)
}

::google::protobuf::uint8* ColumnDescriptor::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:cockroach.proto.ColumnDescriptor)
  // optional uint32 id = 1;
  if (has_id()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(1, this->id(), target);
  }

  // optional .cockroach.proto.Column column = 2;
  if (has_column()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, this->column(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:cockroach.proto.ColumnDescriptor)
  return target;
}

int ColumnDescriptor::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional uint32 id = 1;
    if (has_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->id());
    }

    // optional .cockroach.proto.Column column = 2;
    if (has_column()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->column());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ColumnDescriptor::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const ColumnDescriptor* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const ColumnDescriptor*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void ColumnDescriptor::MergeFrom(const ColumnDescriptor& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_id()) {
      set_id(from.id());
    }
    if (from.has_column()) {
      mutable_column()->::cockroach::proto::Column::MergeFrom(from.column());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void ColumnDescriptor::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void ColumnDescriptor::CopyFrom(const ColumnDescriptor& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ColumnDescriptor::IsInitialized() const {

  return true;
}

void ColumnDescriptor::Swap(ColumnDescriptor* other) {
  if (other != this) {
    std::swap(id_, other->id_);
    std::swap(column_, other->column_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata ColumnDescriptor::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = ColumnDescriptor_descriptor_;
  metadata.reflection = ColumnDescriptor_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int IndexDescriptor::kIdFieldNumber;
const int IndexDescriptor::kIndexFieldNumber;
const int IndexDescriptor::kColumnIdsFieldNumber;
#endif  // !_MSC_VER

IndexDescriptor::IndexDescriptor()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:cockroach.proto.IndexDescriptor)
}

void IndexDescriptor::InitAsDefaultInstance() {
  index_ = const_cast< ::cockroach::proto::Index*>(&::cockroach::proto::Index::default_instance());
}

IndexDescriptor::IndexDescriptor(const IndexDescriptor& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:cockroach.proto.IndexDescriptor)
}

void IndexDescriptor::SharedCtor() {
  _cached_size_ = 0;
  id_ = 0u;
  index_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

IndexDescriptor::~IndexDescriptor() {
  // @@protoc_insertion_point(destructor:cockroach.proto.IndexDescriptor)
  SharedDtor();
}

void IndexDescriptor::SharedDtor() {
  if (this != default_instance_) {
    delete index_;
  }
}

void IndexDescriptor::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* IndexDescriptor::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return IndexDescriptor_descriptor_;
}

const IndexDescriptor& IndexDescriptor::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_cockroach_2fproto_2fstructured_2eproto();
  return *default_instance_;
}

IndexDescriptor* IndexDescriptor::default_instance_ = NULL;

IndexDescriptor* IndexDescriptor::New() const {
  return new IndexDescriptor;
}

void IndexDescriptor::Clear() {
  if (_has_bits_[0 / 32] & 3) {
    id_ = 0u;
    if (has_index()) {
      if (index_ != NULL) index_->::cockroach::proto::Index::Clear();
    }
  }
  column_ids_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool IndexDescriptor::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:cockroach.proto.IndexDescriptor)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional uint32 id = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &id_)));
          set_has_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_index;
        break;
      }

      // optional .cockroach.proto.Index index = 2;
      case 2: {
        if (tag == 18) {
         parse_index:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_index()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_column_ids;
        break;
      }

      // repeated uint32 column_ids = 3;
      case 3: {
        if (tag == 24) {
         parse_column_ids:
          DO_((::google::protobuf::internal::WireFormatLite::ReadRepeatedPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 1, 24, input, this->mutable_column_ids())));
        } else if (tag == 26) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedPrimitiveNoInline<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, this->mutable_column_ids())));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_column_ids;
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:cockroach.proto.IndexDescriptor)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:cockroach.proto.IndexDescriptor)
  return false;
#undef DO_
}

void IndexDescriptor::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:cockroach.proto.IndexDescriptor)
  // optional uint32 id = 1;
  if (has_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->id(), output);
  }

  // optional .cockroach.proto.Index index = 2;
  if (has_index()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, this->index(), output);
  }

  // repeated uint32 column_ids = 3;
  for (int i = 0; i < this->column_ids_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(
      3, this->column_ids(i), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:cockroach.proto.IndexDescriptor)
}

::google::protobuf::uint8* IndexDescriptor::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:cockroach.proto.IndexDescriptor)
  // optional uint32 id = 1;
  if (has_id()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(1, this->id(), target);
  }

  // optional .cockroach.proto.Index index = 2;
  if (has_index()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, this->index(), target);
  }

  // repeated uint32 column_ids = 3;
  for (int i = 0; i < this->column_ids_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteUInt32ToArray(3, this->column_ids(i), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:cockroach.proto.IndexDescriptor)
  return target;
}

int IndexDescriptor::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional uint32 id = 1;
    if (has_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->id());
    }

    // optional .cockroach.proto.Index index = 2;
    if (has_index()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->index());
    }

  }
  // repeated uint32 column_ids = 3;
  {
    int data_size = 0;
    for (int i = 0; i < this->column_ids_size(); i++) {
      data_size += ::google::protobuf::internal::WireFormatLite::
        UInt32Size(this->column_ids(i));
    }
    total_size += 1 * this->column_ids_size() + data_size;
  }

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void IndexDescriptor::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const IndexDescriptor* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const IndexDescriptor*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void IndexDescriptor::MergeFrom(const IndexDescriptor& from) {
  GOOGLE_CHECK_NE(&from, this);
  column_ids_.MergeFrom(from.column_ids_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_id()) {
      set_id(from.id());
    }
    if (from.has_index()) {
      mutable_index()->::cockroach::proto::Index::MergeFrom(from.index());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void IndexDescriptor::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void IndexDescriptor::CopyFrom(const IndexDescriptor& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool IndexDescriptor::IsInitialized() const {

  return true;
}

void IndexDescriptor::Swap(IndexDescriptor* other) {
  if (other != this) {
    std::swap(id_, other->id_);
    std::swap(index_, other->index_);
    column_ids_.Swap(&other->column_ids_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata IndexDescriptor::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = IndexDescriptor_descriptor_;
  metadata.reflection = IndexDescriptor_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int TableDescriptor::kIdFieldNumber;
const int TableDescriptor::kTableFieldNumber;
const int TableDescriptor::kColumnsFieldNumber;
const int TableDescriptor::kNextColumnIdFieldNumber;
const int TableDescriptor::kIndexesFieldNumber;
const int TableDescriptor::kNextIndexIdFieldNumber;
#endif  // !_MSC_VER

TableDescriptor::TableDescriptor()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:cockroach.proto.TableDescriptor)
}

void TableDescriptor::InitAsDefaultInstance() {
  table_ = const_cast< ::cockroach::proto::Table*>(&::cockroach::proto::Table::default_instance());
}

TableDescriptor::TableDescriptor(const TableDescriptor& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:cockroach.proto.TableDescriptor)
}

void TableDescriptor::SharedCtor() {
  _cached_size_ = 0;
  id_ = 0u;
  table_ = NULL;
  next_column_id_ = 0u;
  next_index_id_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

TableDescriptor::~TableDescriptor() {
  // @@protoc_insertion_point(destructor:cockroach.proto.TableDescriptor)
  SharedDtor();
}

void TableDescriptor::SharedDtor() {
  if (this != default_instance_) {
    delete table_;
  }
}

void TableDescriptor::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* TableDescriptor::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return TableDescriptor_descriptor_;
}

const TableDescriptor& TableDescriptor::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_cockroach_2fproto_2fstructured_2eproto();
  return *default_instance_;
}

TableDescriptor* TableDescriptor::default_instance_ = NULL;

TableDescriptor* TableDescriptor::New() const {
  return new TableDescriptor;
}

void TableDescriptor::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<TableDescriptor*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  if (_has_bits_[0 / 32] & 43) {
    ZR_(id_, next_column_id_);
    if (has_table()) {
      if (table_ != NULL) table_->::cockroach::proto::Table::Clear();
    }
    next_index_id_ = 0u;
  }

#undef OFFSET_OF_FIELD_
#undef ZR_

  columns_.Clear();
  indexes_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool TableDescriptor::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:cockroach.proto.TableDescriptor)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional uint32 id = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &id_)));
          set_has_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_table;
        break;
      }

      // optional .cockroach.proto.Table table = 2;
      case 2: {
        if (tag == 18) {
         parse_table:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_table()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(26)) goto parse_columns;
        break;
      }

      // repeated .cockroach.proto.ColumnDescriptor columns = 3;
      case 3: {
        if (tag == 26) {
         parse_columns:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_columns()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(26)) goto parse_columns;
        if (input->ExpectTag(32)) goto parse_next_column_id;
        break;
      }

      // optional uint32 next_column_id = 4;
      case 4: {
        if (tag == 32) {
         parse_next_column_id:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &next_column_id_)));
          set_has_next_column_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(42)) goto parse_indexes;
        break;
      }

      // repeated .cockroach.proto.IndexDescriptor indexes = 5;
      case 5: {
        if (tag == 42) {
         parse_indexes:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_indexes()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(42)) goto parse_indexes;
        if (input->ExpectTag(48)) goto parse_next_index_id;
        break;
      }

      // optional uint32 next_index_id = 6;
      case 6: {
        if (tag == 48) {
         parse_next_index_id:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &next_index_id_)));
          set_has_next_index_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:cockroach.proto.TableDescriptor)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:cockroach.proto.TableDescriptor)
  return false;
#undef DO_
}

void TableDescriptor::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:cockroach.proto.TableDescriptor)
  // optional uint32 id = 1;
  if (has_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->id(), output);
  }

  // optional .cockroach.proto.Table table = 2;
  if (has_table()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, this->table(), output);
  }

  // repeated .cockroach.proto.ColumnDescriptor columns = 3;
  for (int i = 0; i < this->columns_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      3, this->columns(i), output);
  }

  // optional uint32 next_column_id = 4;
  if (has_next_column_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(4, this->next_column_id(), output);
  }

  // repeated .cockroach.proto.IndexDescriptor indexes = 5;
  for (int i = 0; i < this->indexes_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      5, this->indexes(i), output);
  }

  // optional uint32 next_index_id = 6;
  if (has_next_index_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(6, this->next_index_id(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:cockroach.proto.TableDescriptor)
}

::google::protobuf::uint8* TableDescriptor::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:cockroach.proto.TableDescriptor)
  // optional uint32 id = 1;
  if (has_id()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(1, this->id(), target);
  }

  // optional .cockroach.proto.Table table = 2;
  if (has_table()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, this->table(), target);
  }

  // repeated .cockroach.proto.ColumnDescriptor columns = 3;
  for (int i = 0; i < this->columns_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        3, this->columns(i), target);
  }

  // optional uint32 next_column_id = 4;
  if (has_next_column_id()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(4, this->next_column_id(), target);
  }

  // repeated .cockroach.proto.IndexDescriptor indexes = 5;
  for (int i = 0; i < this->indexes_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        5, this->indexes(i), target);
  }

  // optional uint32 next_index_id = 6;
  if (has_next_index_id()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(6, this->next_index_id(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:cockroach.proto.TableDescriptor)
  return target;
}

int TableDescriptor::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional uint32 id = 1;
    if (has_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->id());
    }

    // optional .cockroach.proto.Table table = 2;
    if (has_table()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->table());
    }

    // optional uint32 next_column_id = 4;
    if (has_next_column_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->next_column_id());
    }

    // optional uint32 next_index_id = 6;
    if (has_next_index_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->next_index_id());
    }

  }
  // repeated .cockroach.proto.ColumnDescriptor columns = 3;
  total_size += 1 * this->columns_size();
  for (int i = 0; i < this->columns_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->columns(i));
  }

  // repeated .cockroach.proto.IndexDescriptor indexes = 5;
  total_size += 1 * this->indexes_size();
  for (int i = 0; i < this->indexes_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->indexes(i));
  }

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void TableDescriptor::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const TableDescriptor* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const TableDescriptor*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void TableDescriptor::MergeFrom(const TableDescriptor& from) {
  GOOGLE_CHECK_NE(&from, this);
  columns_.MergeFrom(from.columns_);
  indexes_.MergeFrom(from.indexes_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_id()) {
      set_id(from.id());
    }
    if (from.has_table()) {
      mutable_table()->::cockroach::proto::Table::MergeFrom(from.table());
    }
    if (from.has_next_column_id()) {
      set_next_column_id(from.next_column_id());
    }
    if (from.has_next_index_id()) {
      set_next_index_id(from.next_index_id());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void TableDescriptor::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void TableDescriptor::CopyFrom(const TableDescriptor& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TableDescriptor::IsInitialized() const {

  return true;
}

void TableDescriptor::Swap(TableDescriptor* other) {
  if (other != this) {
    std::swap(id_, other->id_);
    std::swap(table_, other->table_);
    columns_.Swap(&other->columns_);
    std::swap(next_column_id_, other->next_column_id_);
    indexes_.Swap(&other->indexes_);
    std::swap(next_index_id_, other->next_index_id_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata TableDescriptor::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = TableDescriptor_descriptor_;
  metadata.reflection = TableDescriptor_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int CreateTableRequest::kHeaderFieldNumber;
const int CreateTableRequest::kSchemaFieldNumber;
#endif  // !_MSC_VER

CreateTableRequest::CreateTableRequest()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:cockroach.proto.CreateTableRequest)
}

void CreateTableRequest::InitAsDefaultInstance() {
  header_ = const_cast< ::cockroach::proto::RequestHeader*>(&::cockroach::proto::RequestHeader::default_instance());
  schema_ = const_cast< ::cockroach::proto::TableSchema*>(&::cockroach::proto::TableSchema::default_instance());
}

CreateTableRequest::CreateTableRequest(const CreateTableRequest& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:cockroach.proto.CreateTableRequest)
}

void CreateTableRequest::SharedCtor() {
  _cached_size_ = 0;
  header_ = NULL;
  schema_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

CreateTableRequest::~CreateTableRequest() {
  // @@protoc_insertion_point(destructor:cockroach.proto.CreateTableRequest)
  SharedDtor();
}

void CreateTableRequest::SharedDtor() {
  if (this != default_instance_) {
    delete header_;
    delete schema_;
  }
}

void CreateTableRequest::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* CreateTableRequest::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return CreateTableRequest_descriptor_;
}

const CreateTableRequest& CreateTableRequest::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_cockroach_2fproto_2fstructured_2eproto();
  return *default_instance_;
}

CreateTableRequest* CreateTableRequest::default_instance_ = NULL;

CreateTableRequest* CreateTableRequest::New() const {
  return new CreateTableRequest;
}

void CreateTableRequest::Clear() {
  if (_has_bits_[0 / 32] & 3) {
    if (has_header()) {
      if (header_ != NULL) header_->::cockroach::proto::RequestHeader::Clear();
    }
    if (has_schema()) {
      if (schema_ != NULL) schema_->::cockroach::proto::TableSchema::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool CreateTableRequest::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:cockroach.proto.CreateTableRequest)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .cockroach.proto.RequestHeader header = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_header()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_schema;
        break;
      }

      // optional .cockroach.proto.TableSchema schema = 2;
      case 2: {
        if (tag == 18) {
         parse_schema:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_schema()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:cockroach.proto.CreateTableRequest)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:cockroach.proto.CreateTableRequest)
  return false;
#undef DO_
}

void CreateTableRequest::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:cockroach.proto.CreateTableRequest)
  // optional .cockroach.proto.RequestHeader header = 1;
  if (has_header()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->header(), output);
  }

  // optional .cockroach.proto.TableSchema schema = 2;
  if (has_schema()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, this->schema(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:cockroach.proto.CreateTableRequest)
}

::google::protobuf::uint8* CreateTableRequest::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:cockroach.proto.CreateTableRequest)
  // optional .cockroach.proto.RequestHeader header = 1;
  if (has_header()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->header(), target);
  }

  // optional .cockroach.proto.TableSchema schema = 2;
  if (has_schema()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, this->schema(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:cockroach.proto.CreateTableRequest)
  return target;
}

int CreateTableRequest::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional .cockroach.proto.RequestHeader header = 1;
    if (has_header()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->header());
    }

    // optional .cockroach.proto.TableSchema schema = 2;
    if (has_schema()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->schema());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void CreateTableRequest::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const CreateTableRequest* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const CreateTableRequest*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void CreateTableRequest::MergeFrom(const CreateTableRequest& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_header()) {
      mutable_header()->::cockroach::proto::RequestHeader::MergeFrom(from.header());
    }
    if (from.has_schema()) {
      mutable_schema()->::cockroach::proto::TableSchema::MergeFrom(from.schema());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void CreateTableRequest::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void CreateTableRequest::CopyFrom(const CreateTableRequest& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CreateTableRequest::IsInitialized() const {

  return true;
}

void CreateTableRequest::Swap(CreateTableRequest* other) {
  if (other != this) {
    std::swap(header_, other->header_);
    std::swap(schema_, other->schema_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata CreateTableRequest::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = CreateTableRequest_descriptor_;
  metadata.reflection = CreateTableRequest_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int CreateTableResponse::kErrorFieldNumber;
const int CreateTableResponse::kTableIdFieldNumber;
#endif  // !_MSC_VER

CreateTableResponse::CreateTableResponse()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:cockroach.proto.CreateTableResponse)
}

void CreateTableResponse::InitAsDefaultInstance() {
  error_ = const_cast< ::cockroach::proto::Error*>(&::cockroach::proto::Error::default_instance());
}

CreateTableResponse::CreateTableResponse(const CreateTableResponse& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:cockroach.proto.CreateTableResponse)
}

void CreateTableResponse::SharedCtor() {
  _cached_size_ = 0;
  error_ = NULL;
  table_id_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

CreateTableResponse::~CreateTableResponse() {
  // @@protoc_insertion_point(destructor:cockroach.proto.CreateTableResponse)
  SharedDtor();
}

void CreateTableResponse::SharedDtor() {
  if (this != default_instance_) {
    delete error_;
  }
}

void CreateTableResponse::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* CreateTableResponse::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return CreateTableResponse_descriptor_;
}

const CreateTableResponse& CreateTableResponse::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_cockroach_2fproto_2fstructured_2eproto();
  return *default_instance_;
}

CreateTableResponse* CreateTableResponse::default_instance_ = NULL;

CreateTableResponse* CreateTableResponse::New() const {
  return new CreateTableResponse;
}

void CreateTableResponse::Clear() {
  if (_has_bits_[0 / 32] & 3) {
    if (has_error()) {
      if (error_ != NULL) error_->::cockroach::proto::Error::Clear();
    }
    table_id_ = 0u;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool CreateTableResponse::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:cockroach.proto.CreateTableResponse)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .cockroach.proto.Error error = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_error()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_table_id;
        break;
      }

      // optional uint32 table_id = 2;
      case 2: {
        if (tag == 16) {
         parse_table_id:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &table_id_)));
          set_has_table_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:cockroach.proto.CreateTableResponse)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:cockroach.proto.CreateTableResponse)
  return false;
#undef DO_
}

void CreateTableResponse::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:cockroach.proto.CreateTableResponse)
  // optional .cockroach.proto.Error error = 1;
  if (has_error()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->error(), output);
  }

  // optional uint32 table_id = 2;
  if (has_table_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->table_id(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:cockroach.proto.CreateTableResponse)
}

::google::protobuf::uint8* CreateTableResponse::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:cockroach.proto.CreateTableResponse)
  // optional .cockroach.proto.Error error = 1;
  if (has_error()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->error(), target);
  }

  // optional uint32 table_id = 2;
  if (has_table_id()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(2, this->table_id(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:cockroach.proto.CreateTableResponse)
  return target;
}

int CreateTableResponse::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional .cockroach.proto.Error error = 1;
    if (has_error()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->error());
    }

    // optional uint32 table_id = 2;
    if (has_table_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->table_id());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void CreateTableResponse::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const CreateTableResponse* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const CreateTableResponse*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void CreateTableResponse::MergeFrom(const CreateTableResponse& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_error()) {
      mutable_error()->::cockroach::proto::Error::MergeFrom(from.error());
    }
    if (from.has_table_id()) {
      set_table_id(from.table_id());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void CreateTableResponse::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void CreateTableResponse::CopyFrom(const CreateTableResponse& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CreateTableResponse::IsInitialized() const {

  return true;
}

void CreateTableResponse::Swap(CreateTableResponse* other) {
  if (other != this) {
    std::swap(error_, other->error_);
    std::swap(table_id_, other->table_id_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata CreateTableResponse::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = CreateTableResponse_descriptor_;
  metadata.reflection = CreateTableResponse_reflection_;
  return metadata;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace proto
}  // namespace cockroach

// @@protoc_insertion_point(global_scope)
