// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: cockroach/proto/structured.proto

#ifndef PROTOBUF_cockroach_2fproto_2fstructured_2eproto__INCLUDED
#define PROTOBUF_cockroach_2fproto_2fstructured_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2006000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "gogoproto/gogo.pb.h"
#include "cockroach/proto/api.pb.h"
#include "cockroach/proto/errors.pb.h"
// @@protoc_insertion_point(includes)

namespace cockroach {
namespace proto {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_cockroach_2fproto_2fstructured_2eproto();
void protobuf_AssignDesc_cockroach_2fproto_2fstructured_2eproto();
void protobuf_ShutdownFile_cockroach_2fproto_2fstructured_2eproto();

class Table;
class Column;
class Index;
class TableSchema;
class TableSchema_IndexByName;
class ColumnDescriptor;
class IndexDescriptor;
class TableDescriptor;
class CreateTableRequest;
class CreateTableResponse;

enum Column_ColumnType {
  Column_ColumnType_BYTES = 0
};
bool Column_ColumnType_IsValid(int value);
const Column_ColumnType Column_ColumnType_ColumnType_MIN = Column_ColumnType_BYTES;
const Column_ColumnType Column_ColumnType_ColumnType_MAX = Column_ColumnType_BYTES;
const int Column_ColumnType_ColumnType_ARRAYSIZE = Column_ColumnType_ColumnType_MAX + 1;

const ::google::protobuf::EnumDescriptor* Column_ColumnType_descriptor();
inline const ::std::string& Column_ColumnType_Name(Column_ColumnType value) {
  return ::google::protobuf::internal::NameOfEnum(
    Column_ColumnType_descriptor(), value);
}
inline bool Column_ColumnType_Parse(
    const ::std::string& name, Column_ColumnType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Column_ColumnType>(
    Column_ColumnType_descriptor(), name, value);
}
// ===================================================================

class Table : public ::google::protobuf::Message {
 public:
  Table();
  virtual ~Table();

  Table(const Table& from);

  inline Table& operator=(const Table& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Table& default_instance();

  void Swap(Table* other);

  // implements Message ----------------------------------------------

  Table* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Table& from);
  void MergeFrom(const Table& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string name = 1;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // @@protoc_insertion_point(class_scope:cockroach.proto.Table)
 private:
  inline void set_has_name();
  inline void clear_has_name();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* name_;
  friend void  protobuf_AddDesc_cockroach_2fproto_2fstructured_2eproto();
  friend void protobuf_AssignDesc_cockroach_2fproto_2fstructured_2eproto();
  friend void protobuf_ShutdownFile_cockroach_2fproto_2fstructured_2eproto();

  void InitAsDefaultInstance();
  static Table* default_instance_;
};
// -------------------------------------------------------------------

class Column : public ::google::protobuf::Message {
 public:
  Column();
  virtual ~Column();

  Column(const Column& from);

  inline Column& operator=(const Column& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Column& default_instance();

  void Swap(Column* other);

  // implements Message ----------------------------------------------

  Column* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Column& from);
  void MergeFrom(const Column& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef Column_ColumnType ColumnType;
  static const ColumnType BYTES = Column_ColumnType_BYTES;
  static inline bool ColumnType_IsValid(int value) {
    return Column_ColumnType_IsValid(value);
  }
  static const ColumnType ColumnType_MIN =
    Column_ColumnType_ColumnType_MIN;
  static const ColumnType ColumnType_MAX =
    Column_ColumnType_ColumnType_MAX;
  static const int ColumnType_ARRAYSIZE =
    Column_ColumnType_ColumnType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  ColumnType_descriptor() {
    return Column_ColumnType_descriptor();
  }
  static inline const ::std::string& ColumnType_Name(ColumnType value) {
    return Column_ColumnType_Name(value);
  }
  static inline bool ColumnType_Parse(const ::std::string& name,
      ColumnType* value) {
    return Column_ColumnType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional string name = 1;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // optional .cockroach.proto.Column.ColumnType type = 2;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 2;
  inline ::cockroach::proto::Column_ColumnType type() const;
  inline void set_type(::cockroach::proto::Column_ColumnType value);

  // @@protoc_insertion_point(class_scope:cockroach.proto.Column)
 private:
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_type();
  inline void clear_has_type();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* name_;
  int type_;
  friend void  protobuf_AddDesc_cockroach_2fproto_2fstructured_2eproto();
  friend void protobuf_AssignDesc_cockroach_2fproto_2fstructured_2eproto();
  friend void protobuf_ShutdownFile_cockroach_2fproto_2fstructured_2eproto();

  void InitAsDefaultInstance();
  static Column* default_instance_;
};
// -------------------------------------------------------------------

class Index : public ::google::protobuf::Message {
 public:
  Index();
  virtual ~Index();

  Index(const Index& from);

  inline Index& operator=(const Index& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Index& default_instance();

  void Swap(Index* other);

  // implements Message ----------------------------------------------

  Index* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Index& from);
  void MergeFrom(const Index& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string name = 1;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // optional bool unique = 2;
  inline bool has_unique() const;
  inline void clear_unique();
  static const int kUniqueFieldNumber = 2;
  inline bool unique() const;
  inline void set_unique(bool value);

  // @@protoc_insertion_point(class_scope:cockroach.proto.Index)
 private:
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_unique();
  inline void clear_has_unique();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* name_;
  bool unique_;
  friend void  protobuf_AddDesc_cockroach_2fproto_2fstructured_2eproto();
  friend void protobuf_AssignDesc_cockroach_2fproto_2fstructured_2eproto();
  friend void protobuf_ShutdownFile_cockroach_2fproto_2fstructured_2eproto();

  void InitAsDefaultInstance();
  static Index* default_instance_;
};
// -------------------------------------------------------------------

class TableSchema_IndexByName : public ::google::protobuf::Message {
 public:
  TableSchema_IndexByName();
  virtual ~TableSchema_IndexByName();

  TableSchema_IndexByName(const TableSchema_IndexByName& from);

  inline TableSchema_IndexByName& operator=(const TableSchema_IndexByName& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TableSchema_IndexByName& default_instance();

  void Swap(TableSchema_IndexByName* other);

  // implements Message ----------------------------------------------

  TableSchema_IndexByName* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TableSchema_IndexByName& from);
  void MergeFrom(const TableSchema_IndexByName& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .cockroach.proto.Index index = 1;
  inline bool has_index() const;
  inline void clear_index();
  static const int kIndexFieldNumber = 1;
  inline const ::cockroach::proto::Index& index() const;
  inline ::cockroach::proto::Index* mutable_index();
  inline ::cockroach::proto::Index* release_index();
  inline void set_allocated_index(::cockroach::proto::Index* index);

  // repeated string column_names = 2;
  inline int column_names_size() const;
  inline void clear_column_names();
  static const int kColumnNamesFieldNumber = 2;
  inline const ::std::string& column_names(int index) const;
  inline ::std::string* mutable_column_names(int index);
  inline void set_column_names(int index, const ::std::string& value);
  inline void set_column_names(int index, const char* value);
  inline void set_column_names(int index, const char* value, size_t size);
  inline ::std::string* add_column_names();
  inline void add_column_names(const ::std::string& value);
  inline void add_column_names(const char* value);
  inline void add_column_names(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& column_names() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_column_names();

  // @@protoc_insertion_point(class_scope:cockroach.proto.TableSchema.IndexByName)
 private:
  inline void set_has_index();
  inline void clear_has_index();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::cockroach::proto::Index* index_;
  ::google::protobuf::RepeatedPtrField< ::std::string> column_names_;
  friend void  protobuf_AddDesc_cockroach_2fproto_2fstructured_2eproto();
  friend void protobuf_AssignDesc_cockroach_2fproto_2fstructured_2eproto();
  friend void protobuf_ShutdownFile_cockroach_2fproto_2fstructured_2eproto();

  void InitAsDefaultInstance();
  static TableSchema_IndexByName* default_instance_;
};
// -------------------------------------------------------------------

class TableSchema : public ::google::protobuf::Message {
 public:
  TableSchema();
  virtual ~TableSchema();

  TableSchema(const TableSchema& from);

  inline TableSchema& operator=(const TableSchema& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TableSchema& default_instance();

  void Swap(TableSchema* other);

  // implements Message ----------------------------------------------

  TableSchema* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TableSchema& from);
  void MergeFrom(const TableSchema& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef TableSchema_IndexByName IndexByName;

  // accessors -------------------------------------------------------

  // optional .cockroach.proto.Table table = 1;
  inline bool has_table() const;
  inline void clear_table();
  static const int kTableFieldNumber = 1;
  inline const ::cockroach::proto::Table& table() const;
  inline ::cockroach::proto::Table* mutable_table();
  inline ::cockroach::proto::Table* release_table();
  inline void set_allocated_table(::cockroach::proto::Table* table);

  // repeated .cockroach.proto.Column columns = 2;
  inline int columns_size() const;
  inline void clear_columns();
  static const int kColumnsFieldNumber = 2;
  inline const ::cockroach::proto::Column& columns(int index) const;
  inline ::cockroach::proto::Column* mutable_columns(int index);
  inline ::cockroach::proto::Column* add_columns();
  inline const ::google::protobuf::RepeatedPtrField< ::cockroach::proto::Column >&
      columns() const;
  inline ::google::protobuf::RepeatedPtrField< ::cockroach::proto::Column >*
      mutable_columns();

  // repeated .cockroach.proto.TableSchema.IndexByName indexes = 3;
  inline int indexes_size() const;
  inline void clear_indexes();
  static const int kIndexesFieldNumber = 3;
  inline const ::cockroach::proto::TableSchema_IndexByName& indexes(int index) const;
  inline ::cockroach::proto::TableSchema_IndexByName* mutable_indexes(int index);
  inline ::cockroach::proto::TableSchema_IndexByName* add_indexes();
  inline const ::google::protobuf::RepeatedPtrField< ::cockroach::proto::TableSchema_IndexByName >&
      indexes() const;
  inline ::google::protobuf::RepeatedPtrField< ::cockroach::proto::TableSchema_IndexByName >*
      mutable_indexes();

  // @@protoc_insertion_point(class_scope:cockroach.proto.TableSchema)
 private:
  inline void set_has_table();
  inline void clear_has_table();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::cockroach::proto::Table* table_;
  ::google::protobuf::RepeatedPtrField< ::cockroach::proto::Column > columns_;
  ::google::protobuf::RepeatedPtrField< ::cockroach::proto::TableSchema_IndexByName > indexes_;
  friend void  protobuf_AddDesc_cockroach_2fproto_2fstructured_2eproto();
  friend void protobuf_AssignDesc_cockroach_2fproto_2fstructured_2eproto();
  friend void protobuf_ShutdownFile_cockroach_2fproto_2fstructured_2eproto();

  void InitAsDefaultInstance();
  static TableSchema* default_instance_;
};
// -------------------------------------------------------------------

class ColumnDescriptor : public ::google::protobuf::Message {
 public:
  ColumnDescriptor();
  virtual ~ColumnDescriptor();

  ColumnDescriptor(const ColumnDescriptor& from);

  inline ColumnDescriptor& operator=(const ColumnDescriptor& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ColumnDescriptor& default_instance();

  void Swap(ColumnDescriptor* other);

  // implements Message ----------------------------------------------

  ColumnDescriptor* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ColumnDescriptor& from);
  void MergeFrom(const ColumnDescriptor& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline ::google::protobuf::uint32 id() const;
  inline void set_id(::google::protobuf::uint32 value);

  // optional .cockroach.proto.Column column = 2;
  inline bool has_column() const;
  inline void clear_column();
  static const int kColumnFieldNumber = 2;
  inline const ::cockroach::proto::Column& column() const;
  inline ::cockroach::proto::Column* mutable_column();
  inline ::cockroach::proto::Column* release_column();
  inline void set_allocated_column(::cockroach::proto::Column* column);

  // @@protoc_insertion_point(class_scope:cockroach.proto.ColumnDescriptor)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_column();
  inline void clear_has_column();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::cockroach::proto::Column* column_;
  ::google::protobuf::uint32 id_;
  friend void  protobuf_AddDesc_cockroach_2fproto_2fstructured_2eproto();
  friend void protobuf_AssignDesc_cockroach_2fproto_2fstructured_2eproto();
  friend void protobuf_ShutdownFile_cockroach_2fproto_2fstructured_2eproto();

  void InitAsDefaultInstance();
  static ColumnDescriptor* default_instance_;
};
// -------------------------------------------------------------------

class IndexDescriptor : public ::google::protobuf::Message {
 public:
  IndexDescriptor();
  virtual ~IndexDescriptor();

  IndexDescriptor(const IndexDescriptor& from);

  inline IndexDescriptor& operator=(const IndexDescriptor& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const IndexDescriptor& default_instance();

  void Swap(IndexDescriptor* other);

  // implements Message ----------------------------------------------

  IndexDescriptor* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const IndexDescriptor& from);
  void MergeFrom(const IndexDescriptor& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline ::google::protobuf::uint32 id() const;
  inline void set_id(::google::protobuf::uint32 value);

  // optional .cockroach.proto.Index index = 2;
  inline bool has_index() const;
  inline void clear_index();
  static const int kIndexFieldNumber = 2;
  inline const ::cockroach::proto::Index& index() const;
  inline ::cockroach::proto::Index* mutable_index();
  inline ::cockroach::proto::Index* release_index();
  inline void set_allocated_index(::cockroach::proto::Index* index);

  // repeated uint32 column_ids = 3;
  inline int column_ids_size() const;
  inline void clear_column_ids();
  static const int kColumnIdsFieldNumber = 3;
  inline ::google::protobuf::uint32 column_ids(int index) const;
  inline void set_column_ids(int index, ::google::protobuf::uint32 value);
  inline void add_column_ids(::google::protobuf::uint32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      column_ids() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_column_ids();

  // @@protoc_insertion_point(class_scope:cockroach.proto.IndexDescriptor)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_index();
  inline void clear_has_index();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::cockroach::proto::Index* index_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > column_ids_;
  ::google::protobuf::uint32 id_;
  friend void  protobuf_AddDesc_cockroach_2fproto_2fstructured_2eproto();
  friend void protobuf_AssignDesc_cockroach_2fproto_2fstructured_2eproto();
  friend void protobuf_ShutdownFile_cockroach_2fproto_2fstructured_2eproto();

  void InitAsDefaultInstance();
  static IndexDescriptor* default_instance_;
};
// -------------------------------------------------------------------

class TableDescriptor : public ::google::protobuf::Message {
 public:
  TableDescriptor();
  virtual ~TableDescriptor();

  TableDescriptor(const TableDescriptor& from);

  inline TableDescriptor& operator=(const TableDescriptor& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TableDescriptor& default_instance();

  void Swap(TableDescriptor* other);

  // implements Message ----------------------------------------------

  TableDescriptor* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TableDescriptor& from);
  void MergeFrom(const TableDescriptor& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline ::google::protobuf::uint32 id() const;
  inline void set_id(::google::protobuf::uint32 value);

  // optional .cockroach.proto.Table table = 2;
  inline bool has_table() const;
  inline void clear_table();
  static const int kTableFieldNumber = 2;
  inline const ::cockroach::proto::Table& table() const;
  inline ::cockroach::proto::Table* mutable_table();
  inline ::cockroach::proto::Table* release_table();
  inline void set_allocated_table(::cockroach::proto::Table* table);

  // repeated .cockroach.proto.ColumnDescriptor columns = 3;
  inline int columns_size() const;
  inline void clear_columns();
  static const int kColumnsFieldNumber = 3;
  inline const ::cockroach::proto::ColumnDescriptor& columns(int index) const;
  inline ::cockroach::proto::ColumnDescriptor* mutable_columns(int index);
  inline ::cockroach::proto::ColumnDescriptor* add_columns();
  inline const ::google::protobuf::RepeatedPtrField< ::cockroach::proto::ColumnDescriptor >&
      columns() const;
  inline ::google::protobuf::RepeatedPtrField< ::cockroach::proto::ColumnDescriptor >*
      mutable_columns();

  // optional uint32 next_column_id = 4;
  inline bool has_next_column_id() const;
  inline void clear_next_column_id();
  static const int kNextColumnIdFieldNumber = 4;
  inline ::google::protobuf::uint32 next_column_id() const;
  inline void set_next_column_id(::google::protobuf::uint32 value);

  // repeated .cockroach.proto.IndexDescriptor indexes = 5;
  inline int indexes_size() const;
  inline void clear_indexes();
  static const int kIndexesFieldNumber = 5;
  inline const ::cockroach::proto::IndexDescriptor& indexes(int index) const;
  inline ::cockroach::proto::IndexDescriptor* mutable_indexes(int index);
  inline ::cockroach::proto::IndexDescriptor* add_indexes();
  inline const ::google::protobuf::RepeatedPtrField< ::cockroach::proto::IndexDescriptor >&
      indexes() const;
  inline ::google::protobuf::RepeatedPtrField< ::cockroach::proto::IndexDescriptor >*
      mutable_indexes();

  // optional uint32 next_index_id = 6;
  inline bool has_next_index_id() const;
  inline void clear_next_index_id();
  static const int kNextIndexIdFieldNumber = 6;
  inline ::google::protobuf::uint32 next_index_id() const;
  inline void set_next_index_id(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:cockroach.proto.TableDescriptor)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_table();
  inline void clear_has_table();
  inline void set_has_next_column_id();
  inline void clear_has_next_column_id();
  inline void set_has_next_index_id();
  inline void clear_has_next_index_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::cockroach::proto::Table* table_;
  ::google::protobuf::uint32 id_;
  ::google::protobuf::uint32 next_column_id_;
  ::google::protobuf::RepeatedPtrField< ::cockroach::proto::ColumnDescriptor > columns_;
  ::google::protobuf::RepeatedPtrField< ::cockroach::proto::IndexDescriptor > indexes_;
  ::google::protobuf::uint32 next_index_id_;
  friend void  protobuf_AddDesc_cockroach_2fproto_2fstructured_2eproto();
  friend void protobuf_AssignDesc_cockroach_2fproto_2fstructured_2eproto();
  friend void protobuf_ShutdownFile_cockroach_2fproto_2fstructured_2eproto();

  void InitAsDefaultInstance();
  static TableDescriptor* default_instance_;
};
// -------------------------------------------------------------------

class CreateTableRequest : public ::google::protobuf::Message {
 public:
  CreateTableRequest();
  virtual ~CreateTableRequest();

  CreateTableRequest(const CreateTableRequest& from);

  inline CreateTableRequest& operator=(const CreateTableRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CreateTableRequest& default_instance();

  void Swap(CreateTableRequest* other);

  // implements Message ----------------------------------------------

  CreateTableRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CreateTableRequest& from);
  void MergeFrom(const CreateTableRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .cockroach.proto.RequestHeader header = 1;
  inline bool has_header() const;
  inline void clear_header();
  static const int kHeaderFieldNumber = 1;
  inline const ::cockroach::proto::RequestHeader& header() const;
  inline ::cockroach::proto::RequestHeader* mutable_header();
  inline ::cockroach::proto::RequestHeader* release_header();
  inline void set_allocated_header(::cockroach::proto::RequestHeader* header);

  // optional .cockroach.proto.TableSchema schema = 2;
  inline bool has_schema() const;
  inline void clear_schema();
  static const int kSchemaFieldNumber = 2;
  inline const ::cockroach::proto::TableSchema& schema() const;
  inline ::cockroach::proto::TableSchema* mutable_schema();
  inline ::cockroach::proto::TableSchema* release_schema();
  inline void set_allocated_schema(::cockroach::proto::TableSchema* schema);

  // @@protoc_insertion_point(class_scope:cockroach.proto.CreateTableRequest)
 private:
  inline void set_has_header();
  inline void clear_has_header();
  inline void set_has_schema();
  inline void clear_has_schema();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::cockroach::proto::RequestHeader* header_;
  ::cockroach::proto::TableSchema* schema_;
  friend void  protobuf_AddDesc_cockroach_2fproto_2fstructured_2eproto();
  friend void protobuf_AssignDesc_cockroach_2fproto_2fstructured_2eproto();
  friend void protobuf_ShutdownFile_cockroach_2fproto_2fstructured_2eproto();

  void InitAsDefaultInstance();
  static CreateTableRequest* default_instance_;
};
// -------------------------------------------------------------------

class CreateTableResponse : public ::google::protobuf::Message {
 public:
  CreateTableResponse();
  virtual ~CreateTableResponse();

  CreateTableResponse(const CreateTableResponse& from);

  inline CreateTableResponse& operator=(const CreateTableResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CreateTableResponse& default_instance();

  void Swap(CreateTableResponse* other);

  // implements Message ----------------------------------------------

  CreateTableResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CreateTableResponse& from);
  void MergeFrom(const CreateTableResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .cockroach.proto.Error error = 1;
  inline bool has_error() const;
  inline void clear_error();
  static const int kErrorFieldNumber = 1;
  inline const ::cockroach::proto::Error& error() const;
  inline ::cockroach::proto::Error* mutable_error();
  inline ::cockroach::proto::Error* release_error();
  inline void set_allocated_error(::cockroach::proto::Error* error);

  // optional uint32 table_id = 2;
  inline bool has_table_id() const;
  inline void clear_table_id();
  static const int kTableIdFieldNumber = 2;
  inline ::google::protobuf::uint32 table_id() const;
  inline void set_table_id(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:cockroach.proto.CreateTableResponse)
 private:
  inline void set_has_error();
  inline void clear_has_error();
  inline void set_has_table_id();
  inline void clear_has_table_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::cockroach::proto::Error* error_;
  ::google::protobuf::uint32 table_id_;
  friend void  protobuf_AddDesc_cockroach_2fproto_2fstructured_2eproto();
  friend void protobuf_AssignDesc_cockroach_2fproto_2fstructured_2eproto();
  friend void protobuf_ShutdownFile_cockroach_2fproto_2fstructured_2eproto();

  void InitAsDefaultInstance();
  static CreateTableResponse* default_instance_;
};
// ===================================================================


// ===================================================================

// Table

// optional string name = 1;
inline bool Table::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Table::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Table::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Table::clear_name() {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& Table::name() const {
  // @@protoc_insertion_point(field_get:cockroach.proto.Table.name)
  return *name_;
}
inline void Table::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
  // @@protoc_insertion_point(field_set:cockroach.proto.Table.name)
}
inline void Table::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
  // @@protoc_insertion_point(field_set_char:cockroach.proto.Table.name)
}
inline void Table::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:cockroach.proto.Table.name)
}
inline ::std::string* Table::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:cockroach.proto.Table.name)
  return name_;
}
inline ::std::string* Table::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Table::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:cockroach.proto.Table.name)
}

// -------------------------------------------------------------------

// Column

// optional string name = 1;
inline bool Column::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Column::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Column::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Column::clear_name() {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& Column::name() const {
  // @@protoc_insertion_point(field_get:cockroach.proto.Column.name)
  return *name_;
}
inline void Column::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
  // @@protoc_insertion_point(field_set:cockroach.proto.Column.name)
}
inline void Column::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
  // @@protoc_insertion_point(field_set_char:cockroach.proto.Column.name)
}
inline void Column::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:cockroach.proto.Column.name)
}
inline ::std::string* Column::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:cockroach.proto.Column.name)
  return name_;
}
inline ::std::string* Column::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Column::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:cockroach.proto.Column.name)
}

// optional .cockroach.proto.Column.ColumnType type = 2;
inline bool Column::has_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Column::set_has_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Column::clear_has_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Column::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::cockroach::proto::Column_ColumnType Column::type() const {
  // @@protoc_insertion_point(field_get:cockroach.proto.Column.type)
  return static_cast< ::cockroach::proto::Column_ColumnType >(type_);
}
inline void Column::set_type(::cockroach::proto::Column_ColumnType value) {
  assert(::cockroach::proto::Column_ColumnType_IsValid(value));
  set_has_type();
  type_ = value;
  // @@protoc_insertion_point(field_set:cockroach.proto.Column.type)
}

// -------------------------------------------------------------------

// Index

// optional string name = 1;
inline bool Index::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Index::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Index::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Index::clear_name() {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& Index::name() const {
  // @@protoc_insertion_point(field_get:cockroach.proto.Index.name)
  return *name_;
}
inline void Index::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
  // @@protoc_insertion_point(field_set:cockroach.proto.Index.name)
}
inline void Index::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
  // @@protoc_insertion_point(field_set_char:cockroach.proto.Index.name)
}
inline void Index::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:cockroach.proto.Index.name)
}
inline ::std::string* Index::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:cockroach.proto.Index.name)
  return name_;
}
inline ::std::string* Index::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Index::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:cockroach.proto.Index.name)
}

// optional bool unique = 2;
inline bool Index::has_unique() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Index::set_has_unique() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Index::clear_has_unique() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Index::clear_unique() {
  unique_ = false;
  clear_has_unique();
}
inline bool Index::unique() const {
  // @@protoc_insertion_point(field_get:cockroach.proto.Index.unique)
  return unique_;
}
inline void Index::set_unique(bool value) {
  set_has_unique();
  unique_ = value;
  // @@protoc_insertion_point(field_set:cockroach.proto.Index.unique)
}

// -------------------------------------------------------------------

// TableSchema_IndexByName

// optional .cockroach.proto.Index index = 1;
inline bool TableSchema_IndexByName::has_index() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TableSchema_IndexByName::set_has_index() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TableSchema_IndexByName::clear_has_index() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TableSchema_IndexByName::clear_index() {
  if (index_ != NULL) index_->::cockroach::proto::Index::Clear();
  clear_has_index();
}
inline const ::cockroach::proto::Index& TableSchema_IndexByName::index() const {
  // @@protoc_insertion_point(field_get:cockroach.proto.TableSchema.IndexByName.index)
  return index_ != NULL ? *index_ : *default_instance_->index_;
}
inline ::cockroach::proto::Index* TableSchema_IndexByName::mutable_index() {
  set_has_index();
  if (index_ == NULL) index_ = new ::cockroach::proto::Index;
  // @@protoc_insertion_point(field_mutable:cockroach.proto.TableSchema.IndexByName.index)
  return index_;
}
inline ::cockroach::proto::Index* TableSchema_IndexByName::release_index() {
  clear_has_index();
  ::cockroach::proto::Index* temp = index_;
  index_ = NULL;
  return temp;
}
inline void TableSchema_IndexByName::set_allocated_index(::cockroach::proto::Index* index) {
  delete index_;
  index_ = index;
  if (index) {
    set_has_index();
  } else {
    clear_has_index();
  }
  // @@protoc_insertion_point(field_set_allocated:cockroach.proto.TableSchema.IndexByName.index)
}

// repeated string column_names = 2;
inline int TableSchema_IndexByName::column_names_size() const {
  return column_names_.size();
}
inline void TableSchema_IndexByName::clear_column_names() {
  column_names_.Clear();
}
inline const ::std::string& TableSchema_IndexByName::column_names(int index) const {
  // @@protoc_insertion_point(field_get:cockroach.proto.TableSchema.IndexByName.column_names)
  return column_names_.Get(index);
}
inline ::std::string* TableSchema_IndexByName::mutable_column_names(int index) {
  // @@protoc_insertion_point(field_mutable:cockroach.proto.TableSchema.IndexByName.column_names)
  return column_names_.Mutable(index);
}
inline void TableSchema_IndexByName::set_column_names(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:cockroach.proto.TableSchema.IndexByName.column_names)
  column_names_.Mutable(index)->assign(value);
}
inline void TableSchema_IndexByName::set_column_names(int index, const char* value) {
  column_names_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:cockroach.proto.TableSchema.IndexByName.column_names)
}
inline void TableSchema_IndexByName::set_column_names(int index, const char* value, size_t size) {
  column_names_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:cockroach.proto.TableSchema.IndexByName.column_names)
}
inline ::std::string* TableSchema_IndexByName::add_column_names() {
  return column_names_.Add();
}
inline void TableSchema_IndexByName::add_column_names(const ::std::string& value) {
  column_names_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:cockroach.proto.TableSchema.IndexByName.column_names)
}
inline void TableSchema_IndexByName::add_column_names(const char* value) {
  column_names_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:cockroach.proto.TableSchema.IndexByName.column_names)
}
inline void TableSchema_IndexByName::add_column_names(const char* value, size_t size) {
  column_names_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:cockroach.proto.TableSchema.IndexByName.column_names)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
TableSchema_IndexByName::column_names() const {
  // @@protoc_insertion_point(field_list:cockroach.proto.TableSchema.IndexByName.column_names)
  return column_names_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
TableSchema_IndexByName::mutable_column_names() {
  // @@protoc_insertion_point(field_mutable_list:cockroach.proto.TableSchema.IndexByName.column_names)
  return &column_names_;
}

// -------------------------------------------------------------------

// TableSchema

// optional .cockroach.proto.Table table = 1;
inline bool TableSchema::has_table() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TableSchema::set_has_table() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TableSchema::clear_has_table() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TableSchema::clear_table() {
  if (table_ != NULL) table_->::cockroach::proto::Table::Clear();
  clear_has_table();
}
inline const ::cockroach::proto::Table& TableSchema::table() const {
  // @@protoc_insertion_point(field_get:cockroach.proto.TableSchema.table)
  return table_ != NULL ? *table_ : *default_instance_->table_;
}
inline ::cockroach::proto::Table* TableSchema::mutable_table() {
  set_has_table();
  if (table_ == NULL) table_ = new ::cockroach::proto::Table;
  // @@protoc_insertion_point(field_mutable:cockroach.proto.TableSchema.table)
  return table_;
}
inline ::cockroach::proto::Table* TableSchema::release_table() {
  clear_has_table();
  ::cockroach::proto::Table* temp = table_;
  table_ = NULL;
  return temp;
}
inline void TableSchema::set_allocated_table(::cockroach::proto::Table* table) {
  delete table_;
  table_ = table;
  if (table) {
    set_has_table();
  } else {
    clear_has_table();
  }
  // @@protoc_insertion_point(field_set_allocated:cockroach.proto.TableSchema.table)
}

// repeated .cockroach.proto.Column columns = 2;
inline int TableSchema::columns_size() const {
  return columns_.size();
}
inline void TableSchema::clear_columns() {
  columns_.Clear();
}
inline const ::cockroach::proto::Column& TableSchema::columns(int index) const {
  // @@protoc_insertion_point(field_get:cockroach.proto.TableSchema.columns)
  return columns_.Get(index);
}
inline ::cockroach::proto::Column* TableSchema::mutable_columns(int index) {
  // @@protoc_insertion_point(field_mutable:cockroach.proto.TableSchema.columns)
  return columns_.Mutable(index);
}
inline ::cockroach::proto::Column* TableSchema::add_columns() {
  // @@protoc_insertion_point(field_add:cockroach.proto.TableSchema.columns)
  return columns_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::cockroach::proto::Column >&
TableSchema::columns() const {
  // @@protoc_insertion_point(field_list:cockroach.proto.TableSchema.columns)
  return columns_;
}
inline ::google::protobuf::RepeatedPtrField< ::cockroach::proto::Column >*
TableSchema::mutable_columns() {
  // @@protoc_insertion_point(field_mutable_list:cockroach.proto.TableSchema.columns)
  return &columns_;
}

// repeated .cockroach.proto.TableSchema.IndexByName indexes = 3;
inline int TableSchema::indexes_size() const {
  return indexes_.size();
}
inline void TableSchema::clear_indexes() {
  indexes_.Clear();
}
inline const ::cockroach::proto::TableSchema_IndexByName& TableSchema::indexes(int index) const {
  // @@protoc_insertion_point(field_get:cockroach.proto.TableSchema.indexes)
  return indexes_.Get(index);
}
inline ::cockroach::proto::TableSchema_IndexByName* TableSchema::mutable_indexes(int index) {
  // @@protoc_insertion_point(field_mutable:cockroach.proto.TableSchema.indexes)
  return indexes_.Mutable(index);
}
inline ::cockroach::proto::TableSchema_IndexByName* TableSchema::add_indexes() {
  // @@protoc_insertion_point(field_add:cockroach.proto.TableSchema.indexes)
  return indexes_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::cockroach::proto::TableSchema_IndexByName >&
TableSchema::indexes() const {
  // @@protoc_insertion_point(field_list:cockroach.proto.TableSchema.indexes)
  return indexes_;
}
inline ::google::protobuf::RepeatedPtrField< ::cockroach::proto::TableSchema_IndexByName >*
TableSchema::mutable_indexes() {
  // @@protoc_insertion_point(field_mutable_list:cockroach.proto.TableSchema.indexes)
  return &indexes_;
}

// -------------------------------------------------------------------

// ColumnDescriptor

// optional uint32 id = 1;
inline bool ColumnDescriptor::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ColumnDescriptor::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ColumnDescriptor::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ColumnDescriptor::clear_id() {
  id_ = 0u;
  clear_has_id();
}
inline ::google::protobuf::uint32 ColumnDescriptor::id() const {
  // @@protoc_insertion_point(field_get:cockroach.proto.ColumnDescriptor.id)
  return id_;
}
inline void ColumnDescriptor::set_id(::google::protobuf::uint32 value) {
  set_has_id();
  id_ = value;
  // @@protoc_insertion_point(field_set:cockroach.proto.ColumnDescriptor.id)
}

// optional .cockroach.proto.Column column = 2;
inline bool ColumnDescriptor::has_column() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ColumnDescriptor::set_has_column() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ColumnDescriptor::clear_has_column() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ColumnDescriptor::clear_column() {
  if (column_ != NULL) column_->::cockroach::proto::Column::Clear();
  clear_has_column();
}
inline const ::cockroach::proto::Column& ColumnDescriptor::column() const {
  // @@protoc_insertion_point(field_get:cockroach.proto.ColumnDescriptor.column)
  return column_ != NULL ? *column_ : *default_instance_->column_;
}
inline ::cockroach::proto::Column* ColumnDescriptor::mutable_column() {
  set_has_column();
  if (column_ == NULL) column_ = new ::cockroach::proto::Column;
  // @@protoc_insertion_point(field_mutable:cockroach.proto.ColumnDescriptor.column)
  return column_;
}
inline ::cockroach::proto::Column* ColumnDescriptor::release_column() {
  clear_has_column();
  ::cockroach::proto::Column* temp = column_;
  column_ = NULL;
  return temp;
}
inline void ColumnDescriptor::set_allocated_column(::cockroach::proto::Column* column) {
  delete column_;
  column_ = column;
  if (column) {
    set_has_column();
  } else {
    clear_has_column();
  }
  // @@protoc_insertion_point(field_set_allocated:cockroach.proto.ColumnDescriptor.column)
}

// -------------------------------------------------------------------

// IndexDescriptor

// optional uint32 id = 1;
inline bool IndexDescriptor::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void IndexDescriptor::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void IndexDescriptor::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void IndexDescriptor::clear_id() {
  id_ = 0u;
  clear_has_id();
}
inline ::google::protobuf::uint32 IndexDescriptor::id() const {
  // @@protoc_insertion_point(field_get:cockroach.proto.IndexDescriptor.id)
  return id_;
}
inline void IndexDescriptor::set_id(::google::protobuf::uint32 value) {
  set_has_id();
  id_ = value;
  // @@protoc_insertion_point(field_set:cockroach.proto.IndexDescriptor.id)
}

// optional .cockroach.proto.Index index = 2;
inline bool IndexDescriptor::has_index() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void IndexDescriptor::set_has_index() {
  _has_bits_[0] |= 0x00000002u;
}
inline void IndexDescriptor::clear_has_index() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void IndexDescriptor::clear_index() {
  if (index_ != NULL) index_->::cockroach::proto::Index::Clear();
  clear_has_index();
}
inline const ::cockroach::proto::Index& IndexDescriptor::index() const {
  // @@protoc_insertion_point(field_get:cockroach.proto.IndexDescriptor.index)
  return index_ != NULL ? *index_ : *default_instance_->index_;
}
inline ::cockroach::proto::Index* IndexDescriptor::mutable_index() {
  set_has_index();
  if (index_ == NULL) index_ = new ::cockroach::proto::Index;
  // @@protoc_insertion_point(field_mutable:cockroach.proto.IndexDescriptor.index)
  return index_;
}
inline ::cockroach::proto::Index* IndexDescriptor::release_index() {
  clear_has_index();
  ::cockroach::proto::Index* temp = index_;
  index_ = NULL;
  return temp;
}
inline void IndexDescriptor::set_allocated_index(::cockroach::proto::Index* index) {
  delete index_;
  index_ = index;
  if (index) {
    set_has_index();
  } else {
    clear_has_index();
  }
  // @@protoc_insertion_point(field_set_allocated:cockroach.proto.IndexDescriptor.index)
}

// repeated uint32 column_ids = 3;
inline int IndexDescriptor::column_ids_size() const {
  return column_ids_.size();
}
inline void IndexDescriptor::clear_column_ids() {
  column_ids_.Clear();
}
inline ::google::protobuf::uint32 IndexDescriptor::column_ids(int index) const {
  // @@protoc_insertion_point(field_get:cockroach.proto.IndexDescriptor.column_ids)
  return column_ids_.Get(index);
}
inline void IndexDescriptor::set_column_ids(int index, ::google::protobuf::uint32 value) {
  column_ids_.Set(index, value);
  // @@protoc_insertion_point(field_set:cockroach.proto.IndexDescriptor.column_ids)
}
inline void IndexDescriptor::add_column_ids(::google::protobuf::uint32 value) {
  column_ids_.Add(value);
  // @@protoc_insertion_point(field_add:cockroach.proto.IndexDescriptor.column_ids)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
IndexDescriptor::column_ids() const {
  // @@protoc_insertion_point(field_list:cockroach.proto.IndexDescriptor.column_ids)
  return column_ids_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
IndexDescriptor::mutable_column_ids() {
  // @@protoc_insertion_point(field_mutable_list:cockroach.proto.IndexDescriptor.column_ids)
  return &column_ids_;
}

// -------------------------------------------------------------------

// TableDescriptor

// optional uint32 id = 1;
inline bool TableDescriptor::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TableDescriptor::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TableDescriptor::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TableDescriptor::clear_id() {
  id_ = 0u;
  clear_has_id();
}
inline ::google::protobuf::uint32 TableDescriptor::id() const {
  // @@protoc_insertion_point(field_get:cockroach.proto.TableDescriptor.id)
  return id_;
}
inline void TableDescriptor::set_id(::google::protobuf::uint32 value) {
  set_has_id();
  id_ = value;
  // @@protoc_insertion_point(field_set:cockroach.proto.TableDescriptor.id)
}

// optional .cockroach.proto.Table table = 2;
inline bool TableDescriptor::has_table() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TableDescriptor::set_has_table() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TableDescriptor::clear_has_table() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TableDescriptor::clear_table() {
  if (table_ != NULL) table_->::cockroach::proto::Table::Clear();
  clear_has_table();
}
inline const ::cockroach::proto::Table& TableDescriptor::table() const {
  // @@protoc_insertion_point(field_get:cockroach.proto.TableDescriptor.table)
  return table_ != NULL ? *table_ : *default_instance_->table_;
}
inline ::cockroach::proto::Table* TableDescriptor::mutable_table() {
  set_has_table();
  if (table_ == NULL) table_ = new ::cockroach::proto::Table;
  // @@protoc_insertion_point(field_mutable:cockroach.proto.TableDescriptor.table)
  return table_;
}
inline ::cockroach::proto::Table* TableDescriptor::release_table() {
  clear_has_table();
  ::cockroach::proto::Table* temp = table_;
  table_ = NULL;
  return temp;
}
inline void TableDescriptor::set_allocated_table(::cockroach::proto::Table* table) {
  delete table_;
  table_ = table;
  if (table) {
    set_has_table();
  } else {
    clear_has_table();
  }
  // @@protoc_insertion_point(field_set_allocated:cockroach.proto.TableDescriptor.table)
}

// repeated .cockroach.proto.ColumnDescriptor columns = 3;
inline int TableDescriptor::columns_size() const {
  return columns_.size();
}
inline void TableDescriptor::clear_columns() {
  columns_.Clear();
}
inline const ::cockroach::proto::ColumnDescriptor& TableDescriptor::columns(int index) const {
  // @@protoc_insertion_point(field_get:cockroach.proto.TableDescriptor.columns)
  return columns_.Get(index);
}
inline ::cockroach::proto::ColumnDescriptor* TableDescriptor::mutable_columns(int index) {
  // @@protoc_insertion_point(field_mutable:cockroach.proto.TableDescriptor.columns)
  return columns_.Mutable(index);
}
inline ::cockroach::proto::ColumnDescriptor* TableDescriptor::add_columns() {
  // @@protoc_insertion_point(field_add:cockroach.proto.TableDescriptor.columns)
  return columns_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::cockroach::proto::ColumnDescriptor >&
TableDescriptor::columns() const {
  // @@protoc_insertion_point(field_list:cockroach.proto.TableDescriptor.columns)
  return columns_;
}
inline ::google::protobuf::RepeatedPtrField< ::cockroach::proto::ColumnDescriptor >*
TableDescriptor::mutable_columns() {
  // @@protoc_insertion_point(field_mutable_list:cockroach.proto.TableDescriptor.columns)
  return &columns_;
}

// optional uint32 next_column_id = 4;
inline bool TableDescriptor::has_next_column_id() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TableDescriptor::set_has_next_column_id() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TableDescriptor::clear_has_next_column_id() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TableDescriptor::clear_next_column_id() {
  next_column_id_ = 0u;
  clear_has_next_column_id();
}
inline ::google::protobuf::uint32 TableDescriptor::next_column_id() const {
  // @@protoc_insertion_point(field_get:cockroach.proto.TableDescriptor.next_column_id)
  return next_column_id_;
}
inline void TableDescriptor::set_next_column_id(::google::protobuf::uint32 value) {
  set_has_next_column_id();
  next_column_id_ = value;
  // @@protoc_insertion_point(field_set:cockroach.proto.TableDescriptor.next_column_id)
}

// repeated .cockroach.proto.IndexDescriptor indexes = 5;
inline int TableDescriptor::indexes_size() const {
  return indexes_.size();
}
inline void TableDescriptor::clear_indexes() {
  indexes_.Clear();
}
inline const ::cockroach::proto::IndexDescriptor& TableDescriptor::indexes(int index) const {
  // @@protoc_insertion_point(field_get:cockroach.proto.TableDescriptor.indexes)
  return indexes_.Get(index);
}
inline ::cockroach::proto::IndexDescriptor* TableDescriptor::mutable_indexes(int index) {
  // @@protoc_insertion_point(field_mutable:cockroach.proto.TableDescriptor.indexes)
  return indexes_.Mutable(index);
}
inline ::cockroach::proto::IndexDescriptor* TableDescriptor::add_indexes() {
  // @@protoc_insertion_point(field_add:cockroach.proto.TableDescriptor.indexes)
  return indexes_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::cockroach::proto::IndexDescriptor >&
TableDescriptor::indexes() const {
  // @@protoc_insertion_point(field_list:cockroach.proto.TableDescriptor.indexes)
  return indexes_;
}
inline ::google::protobuf::RepeatedPtrField< ::cockroach::proto::IndexDescriptor >*
TableDescriptor::mutable_indexes() {
  // @@protoc_insertion_point(field_mutable_list:cockroach.proto.TableDescriptor.indexes)
  return &indexes_;
}

// optional uint32 next_index_id = 6;
inline bool TableDescriptor::has_next_index_id() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void TableDescriptor::set_has_next_index_id() {
  _has_bits_[0] |= 0x00000020u;
}
inline void TableDescriptor::clear_has_next_index_id() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void TableDescriptor::clear_next_index_id() {
  next_index_id_ = 0u;
  clear_has_next_index_id();
}
inline ::google::protobuf::uint32 TableDescriptor::next_index_id() const {
  // @@protoc_insertion_point(field_get:cockroach.proto.TableDescriptor.next_index_id)
  return next_index_id_;
}
inline void TableDescriptor::set_next_index_id(::google::protobuf::uint32 value) {
  set_has_next_index_id();
  next_index_id_ = value;
  // @@protoc_insertion_point(field_set:cockroach.proto.TableDescriptor.next_index_id)
}

// -------------------------------------------------------------------

// CreateTableRequest

// optional .cockroach.proto.RequestHeader header = 1;
inline bool CreateTableRequest::has_header() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CreateTableRequest::set_has_header() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CreateTableRequest::clear_has_header() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CreateTableRequest::clear_header() {
  if (header_ != NULL) header_->::cockroach::proto::RequestHeader::Clear();
  clear_has_header();
}
inline const ::cockroach::proto::RequestHeader& CreateTableRequest::header() const {
  // @@protoc_insertion_point(field_get:cockroach.proto.CreateTableRequest.header)
  return header_ != NULL ? *header_ : *default_instance_->header_;
}
inline ::cockroach::proto::RequestHeader* CreateTableRequest::mutable_header() {
  set_has_header();
  if (header_ == NULL) header_ = new ::cockroach::proto::RequestHeader;
  // @@protoc_insertion_point(field_mutable:cockroach.proto.CreateTableRequest.header)
  return header_;
}
inline ::cockroach::proto::RequestHeader* CreateTableRequest::release_header() {
  clear_has_header();
  ::cockroach::proto::RequestHeader* temp = header_;
  header_ = NULL;
  return temp;
}
inline void CreateTableRequest::set_allocated_header(::cockroach::proto::RequestHeader* header) {
  delete header_;
  header_ = header;
  if (header) {
    set_has_header();
  } else {
    clear_has_header();
  }
  // @@protoc_insertion_point(field_set_allocated:cockroach.proto.CreateTableRequest.header)
}

// optional .cockroach.proto.TableSchema schema = 2;
inline bool CreateTableRequest::has_schema() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CreateTableRequest::set_has_schema() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CreateTableRequest::clear_has_schema() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CreateTableRequest::clear_schema() {
  if (schema_ != NULL) schema_->::cockroach::proto::TableSchema::Clear();
  clear_has_schema();
}
inline const ::cockroach::proto::TableSchema& CreateTableRequest::schema() const {
  // @@protoc_insertion_point(field_get:cockroach.proto.CreateTableRequest.schema)
  return schema_ != NULL ? *schema_ : *default_instance_->schema_;
}
inline ::cockroach::proto::TableSchema* CreateTableRequest::mutable_schema() {
  set_has_schema();
  if (schema_ == NULL) schema_ = new ::cockroach::proto::TableSchema;
  // @@protoc_insertion_point(field_mutable:cockroach.proto.CreateTableRequest.schema)
  return schema_;
}
inline ::cockroach::proto::TableSchema* CreateTableRequest::release_schema() {
  clear_has_schema();
  ::cockroach::proto::TableSchema* temp = schema_;
  schema_ = NULL;
  return temp;
}
inline void CreateTableRequest::set_allocated_schema(::cockroach::proto::TableSchema* schema) {
  delete schema_;
  schema_ = schema;
  if (schema) {
    set_has_schema();
  } else {
    clear_has_schema();
  }
  // @@protoc_insertion_point(field_set_allocated:cockroach.proto.CreateTableRequest.schema)
}

// -------------------------------------------------------------------

// CreateTableResponse

// optional .cockroach.proto.Error error = 1;
inline bool CreateTableResponse::has_error() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CreateTableResponse::set_has_error() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CreateTableResponse::clear_has_error() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CreateTableResponse::clear_error() {
  if (error_ != NULL) error_->::cockroach::proto::Error::Clear();
  clear_has_error();
}
inline const ::cockroach::proto::Error& CreateTableResponse::error() const {
  // @@protoc_insertion_point(field_get:cockroach.proto.CreateTableResponse.error)
  return error_ != NULL ? *error_ : *default_instance_->error_;
}
inline ::cockroach::proto::Error* CreateTableResponse::mutable_error() {
  set_has_error();
  if (error_ == NULL) error_ = new ::cockroach::proto::Error;
  // @@protoc_insertion_point(field_mutable:cockroach.proto.CreateTableResponse.error)
  return error_;
}
inline ::cockroach::proto::Error* CreateTableResponse::release_error() {
  clear_has_error();
  ::cockroach::proto::Error* temp = error_;
  error_ = NULL;
  return temp;
}
inline void CreateTableResponse::set_allocated_error(::cockroach::proto::Error* error) {
  delete error_;
  error_ = error;
  if (error) {
    set_has_error();
  } else {
    clear_has_error();
  }
  // @@protoc_insertion_point(field_set_allocated:cockroach.proto.CreateTableResponse.error)
}

// optional uint32 table_id = 2;
inline bool CreateTableResponse::has_table_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CreateTableResponse::set_has_table_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CreateTableResponse::clear_has_table_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CreateTableResponse::clear_table_id() {
  table_id_ = 0u;
  clear_has_table_id();
}
inline ::google::protobuf::uint32 CreateTableResponse::table_id() const {
  // @@protoc_insertion_point(field_get:cockroach.proto.CreateTableResponse.table_id)
  return table_id_;
}
inline void CreateTableResponse::set_table_id(::google::protobuf::uint32 value) {
  set_has_table_id();
  table_id_ = value;
  // @@protoc_insertion_point(field_set:cockroach.proto.CreateTableResponse.table_id)
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace proto
}  // namespace cockroach

#ifndef SWIG
namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::cockroach::proto::Column_ColumnType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::cockroach::proto::Column_ColumnType>() {
  return ::cockroach::proto::Column_ColumnType_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_cockroach_2fproto_2fstructured_2eproto__INCLUDED
