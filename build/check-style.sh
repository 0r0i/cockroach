#!/bin/bash

set -eu

PKG=${PKG:-./...}

echo "checking for missing license headers"
! git grep -LE '^// (Copyright|Code generated by)' -- '*.go'
echo "checking for time.Now and time.Since calls (use timeutil instead)"
! git grep -nE 'time\.(Now|Since)' -- '*.go' | grep -vE '^util/(log|timeutil)/\w+\.go\b'
echo "checking for os.Getenv calls (use envutil.EnvOrDefault*() instead)"
! git grep -nF 'os.Getenv' -- '*.go' | grep -vE '^((util/(log|envutil|sdnotify))|acceptance(/.*)?)/\w+\.go\b'
echo "checking for proto.Clone calls (use protoutil.Clone instead)"
! git grep -nE '\.Clone\([^)]+\)' -- '*.go' | grep -vF 'protoutil.Clone' | grep -vE '^util/protoutil/clone(_test)?\.go\b'
echo "checking for proto.Marshal calls (use protoutil.Marshal instead)"
! git grep -nE '\.Marshal\([^)]+\)' -- '*.go' | grep -vE '(json|yaml|protoutil)\.Marshal' | grep -vE '^util/protoutil/marshal(_test)?\.go\b'
echo "checking for grpc.NewServer calls (use rpc.NewServer instead)"
! git grep -nF 'grpc.NewServer()' -- '*.go' | grep -vE '^rpc/context(_test)?\.go\b'
echo "checking for missing defer leaktest.AfterTest"
util/leaktest/check-leaktest.sh
echo "misspell"
! git ls-files | xargs misspell | grep -vF 'No Exceptions'
echo "checking for tabs in shell scripts"
! git grep -F '	' -- '*.sh'
echo "checking for forbidden imports"
go list -f '{{ $ip := .ImportPath }}{{ range .Imports}}{{ $ip }}: {{ println . }}{{end}}{{ range .TestImports}}{{ $ip }}: {{ println . }}{{end}}{{ range .XTestImports}}{{ $ip }}: {{ println . }}{{end}}' "$PKG" | \
       grep -E ' (github.com/golang/protobuf/proto|github.com/satori/go\.uuid|log|path)$' | \
       grep -Ev 'cockroach/(base|security|util/(log|randutil|stop)): log$' | \
       grep -vF 'util/uuid: github.com/satori/go.uuid' | tee forbidden.log; \
  if grep -E ' path$' forbidden.log > /dev/null; then \
       echo; echo "Consider using 'path/filepath' instead of 'path'."; echo; \
  fi; \
  if grep -E ' log$' forbidden.log > /dev/null; then \
       echo; echo "Consider using 'util/log' instead of 'log'."; echo; \
  fi; \
  if grep -E ' github.com/golang/protobuf/proto$' forbidden.log > /dev/null; then \
       echo; echo "Consider using 'gogo/protobuf/proto' instead of 'golang/protobuf/proto'."; echo; \
  fi; \
  if grep -E ' github.com/satori/go\.uuid$' forbidden.log > /dev/null; then \
       echo; echo "Consider using 'util/uuid' instead of 'satori/go.uuid'."; echo; \
  fi; \
  test ! -s forbidden.log
rm -f forbidden.log
echo "ineffassign"
! ineffassign . | grep -vF '.pb.go' # gogo/protobuf#152
echo "errcheck"
errcheck -ignore 'bytes:Write.*,io:Close,net:Close,net/http:Close,net/rpc:Close,os:Close,database/sql:Close' "$PKG"
echo "returncheck"
returncheck "$PKG"
echo "vet"
! go tool vet . 2>&1 | \
 grep -vE '^vet: cannot process directory .git' | \
 grep -vE '^server/admin\..*\go:.+: constant [0-9]+ not a string in call to Errorf' \
 # To return proper HTTP error codes (e.g. 404 Not Found), we need to use \
 # grpc.Errorf, which has an error code as its first parameter. 'go vet' \
 # doesn't like that the first parameter isn't a format string.
echo "vet --shadow"
! go tool vet --shadow . 2>&1 | \
 grep -vE '(declaration of (pE|e)rr shadows|^vet: cannot process directory \.git)' | \
 grep -vE '\.pb\.gw\.go'
echo "golint"
! golint "$PKG" | \
 grep -vE '(\.pb\.go|\.pb\.gw\.go|embedded\.go|_string\.go|LastInsertId|sql/parser/(yaccpar|sql\.y):)' \
 # https://golang.org/pkg/database/sql/driver/#Result :(
echo "varcheck"
! varcheck -e "$PKG" | \
 grep -vE '(_string.go|sql/parser/(yacctab|sql\.y))'
echo "gofmt (simplify)"
! gofmt -s -d -l . 2>&1 | grep -vE '^\.git/'
echo "goimports"
! goimports -l . | grep -vF 'No Exceptions'
echo "unused"
! unused -exported ./... | grep -vE '(\.pb\.go:|/C:|_string.go:|embedded.go:|parser/(yacc|sql.y)|util/interval/interval.go:|_cgo|Mutex)'
