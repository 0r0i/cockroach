YACC := ../../../../../../bin/yacc

.PHONY: all
all: sql.go keywords.go reserved_keywords.go

sql.go: sql.y
	$(YACC) -o sql.go -p sql sql.y
	@echo '// Code generated by go yacc.' | \
	  cat - sql.go > sql.go.tmp && mv -f sql.go.tmp sql.go

reserved_keywords.go: sql.y reserved_keywords.awk
	awk -f reserved_keywords.awk < sql.y > reserved_keywords.go
	gofmt -s -w reserved_keywords.go

keywords.go: sql.y all_keywords.awk
	printf "// Code generated by all_keywords.awk.\n\n" > keywords.go
	printf "package parser\n\n" >> keywords.go
	printf "var keywords = map[string]int{\n" >> keywords.go
	for kw in $$(awk -f all_keywords.awk < sql.y | sort); do \
	  printf "\"%s\": %s,\n" $${kw} $${kw}; \
	done >> keywords.go
	printf "}\n" >> keywords.go
	gofmt -s -w keywords.go

# This target will print unreserved_keywords which are not actually
# used in the grammar.
.PHONY: unused_unreserved_keywords
unused_unreserved_keywords:
	@for kw in $$(awk -f unreserved_keywords.awk < sql.y); do \
	  if [ $$(grep -c $${kw} sql.y) -le 2 ]; then \
	    echo $${kw}; \
	  fi \
	done
